<!DOCTYPE html>
<html lang="en">

<head>
    <title>Web App</title>
    <style>




    </style>
</head>

<body>


    <script>
        //循环链表和链表唯一的区别在于最后一个元素指向下一个元素的指针（tail.next），不是引用undefined，而是指向第一个元素（head）
      //都可以在单链表基础上进行组装

        class Node {

            constructor(element) {
                this.element = element;
                this.next = null;
            }
        }


        class LinkedList {

            constructor(element) {
                this.count = 0
                this.head = null

            }

            push(element) {
                let node = new Node(element)

                if (this.head === null) {
                    this.head = node

                } else {
                    let current = this.head     //这个新的变量是为了保护链表的原始head不受改变，但是指针指向最后的node
                    while (current.next !== null) {
                        current = current.next
                    }
                    current.next = node
                }
                this.count++

            }
            // 找到需要位置的node（从head开始往后找）
            getNodeAt(index) {
                if (index >= 0 && index < this.count) {
                    let node = this.head
                    for (let i = 0; i < index; i++) {
                        node = node.next
                    }
                    return node
                }

                return
            }

            //指定位置删除(0,1,2位置)
            removeAt(index) {
                if (index >= 0 && index < this.count) {
                    let current = this.head
                    if (index === 0) {
                        this.head = this.head.next
                    } else {
                        let previous = this.getNodeAt(index - 1)
                        current = previous.next
                        previous.next = current.next

                    }
                    this.count--

                    return current.element
                }
                return                       //这里不定义直接返回 undefined
            }


            indexOf(el) {

                let current = this.head
                for (let i = 0; i < this.count; i++) {
                    if (JSON.stringify(current.element) === JSON.stringify(el)) {            //先将对象(obj)转换为字符串，然后比较字符串.这是为了避免node中储存object类型的数据，因为object类型的数据无法比较
                        return i
                    }
                    current = current.next

                }
                return -1
            }
            //删除给出的值
            remove(element) {
                let index = this.indexOf(element)
                return this.removeAt(index)


            }

            insert(element, index) {
                if (index >= 0 && index <= this.count) {   //注意这个index<=this.count中的🟰，表面插入在空集合里面的一个数
                    const node = new Node(element)
                    if (index === 0) {
                        let current = this.head
                        node.next = current
                        this.head = node
                    } else {
                        let previous = this.getNodeAt(index - 1)
                        let current = previous.next
                        previous.next = node
                        node.next = current
                    }
                    this.count++
                    return true
                }
                return false
            }



            isEmpty() {
                return this.size() === 0
            }
            size() {
                return this.count
            }




        }
        let newList = new LinkedList()

        




    </script>
    <script>
        //这是一个双向链表节点的类定义，继承了普通的单向链表节点
       

        class CircleLinkedList extends LinkedList {

            constructor() {
                super()
                

            }

            push(element) {
                let node = new Node(element)
                if (this.head === null) {
                    this.head=node
                    
                   
                   
                } else {
                    let current=this.getNodeAt(this.size()-1)
                    current.next=node
                    

                }
                node.next = this.head
                this.count++

            }
            insert(element, index) {
                if (index >= 0 && index <= this.count) {   //注意这个index<=this.count中的🟰，考虑count=0的情况，插入在空集合里面的一个数
                    const node = new Node(element)
                    let current = this.head
                    if (index === 0) {
                        if(this.head===null){
                            this.head=node
                            node.next=this.head
                        }else{
                            node.next = current
                         current = this.getNodeAt(this.size() - 1) //不能放在this.head = node后面，不能插入一个新元素之后再处理排在最后的数
                            this.head = node
                        
                            current.next=this.head
                        }    
                           
                    } else {
                        let previous = this.getNodeAt(index - 1)
                            current = previous.next
                           previous.next = node
                            node.next = current
                    }
                    this.count++
                    return true
                }
                return false
            }

            removeAt(index) {
                if (index >= 0 && index < this.count) {
                    let current = this.head
                    if (index === 0) {
                        if(this.count===1){
                            this.head=undefined
                        }else{
                            let last= this.getNodeAt(this.size() - 1)//注意顺序，不能将this.head=this.head.next写前面
                            this.head = this.head.next
                            last.next=this.head

                        }    
                    } else {
                        let previous = this.getNodeAt(index - 1)
                        current = previous.next
                        previous.next = current.next

                    }
                    this.count--

                    return current.element
                }
                return                       //这里不定义直接返回 undefined

            }







            getHead() {
                return this.head

            }
            getTail() {
                return this.tail

            }
        }

        let list = new CircleLinkedList()
    </script>

</body>

</html>