<!DOCTYPE html>
<html lang="en">

<head>
  <title>Web App</title>
  <style>
    
   
      
    
  </style>
</head>

<body>
  
  
  <script>
    //链表就像火车，一节一节的连接起来，插入和删除的操作非常简单O（1）（只需要更改指针指向即可）。
    // 但是和array相比，没有index的指引，无法迅速找到指定的index，必须从表头开始一个一个的寻找

  //容器类（DeQueue、Queue、Stack）：通常不需要constructor，因为它们的主要作用是提供操作方法，初始状态一般是空的
  //数据类（Node）：需要constructor，因为每个实例都需要存储特定的数据

  //单链表 实现的功能有：删除指定index/element的node，插入指定的node

  class Node{

    constructor(element){
      this.element=element;
      this.next=null;
    }
  }
  

  class LinkedList{

    constructor(element){
      this.count=0
      this.head=null

    }

    push(element){
      let node=new Node(element)

      if(this.head===null){
        this.head=node

      }else{
        let current=this.head     //这个新的变量是为了保护链表的原始head不受改变，但是指针指向最后的node
        while(current.next!==null){
          current=current.next
        }
        current.next=node 
      }
      this.count++

    }
    // 找到需要位置的node（从head开始往后找）
    getNodeAt(index){
       if (index >= 0 && index < this.count) {
        let node=this.head
        for(let i=0;i<index;i++){
          node=node.next
        }
        return node
       }

      return
    }

    //指定位置删除(0,1,2位置)
    removeAt(index){
      if(index>=0&&index<this.count){
        let current = this.head
        if (index===0) {
          this.head=this.head.next
        }else{
          let previous=this.getNodeAt(index-1)
          current=previous.next
          previous.next=current.next

        }
        this.count--

         return current.element
    }
    return                       //这里不定义直接返回 undefined
  }


  indexOf(el){
    
    let current=this.head
    for(let i=0;i<this.count;i++){
      if(JSON.stringify(current.element)=== JSON.stringify(el)){            //先将对象(obj)转换为字符串，然后比较字符串.这是为了避免node中储存object类型的数据，因为object类型的数据无法比较
        return i
      }
      current=current.next

    }
    return -1
  }
//删除给出的值
remove(element){
   let index=this.indexOf(element)
   return this.removeAt(index)


}

insert(element,index){
  if(index>=0&&index<=this.count){   //注意这个index<=this.count中的🟰，考虑count=0的情况，插入在空集合里面的一个数
    const node=new Node(element)
    if(index===0){
      let current=this.head
      node.next=current
      this.head=node
    }else{
      let previous=this.getNodeAt(index-1)
      let current=previous.next
      previous.next=node
      node.next=current
    }
    this.count++
    return true
  }
  return false
}

isEmpty(){
  return this.size()===0
}
size(){
  return this.count
}




  }
  let newList=new LinkedList()

  // 链表的运用------回文检查：前后读都一样

  function test(str) {
    let newStr = str.toLowerCase().split(' ').join('')
    let dequeue = new LinkedList()
    for (let i = 0; i < newStr.length; i++) {
      dequeue.push(newStr[i])
    }

    while (dequeue.size() > 1) {
      if (dequeue.removeAt(0)!== dequeue.removeAt(dequeue.size()-1)) {

        return false

      }
    }
    return true



  }
  console.log(test('w qq    W'))




  </script>

</body>

</html>