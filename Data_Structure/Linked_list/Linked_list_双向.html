<!DOCTYPE html>
<html lang="en">

<head>
    <title>Web App</title>
    <style>




    </style>
</head>

<body>


    <script>
        //åŒå‘é“¾è¡¨ï¼šé™¤äº†å‚¨å­˜æ•°æ®ä»¥å¤–ï¼Œè¿˜æœ‰ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹åœ°å€ï¼ˆprev)å’Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹åœ°å€ï¼ˆnext)
        

        class Node {

            constructor(element) {
                this.element = element;
                this.next = null;
            }
        }


        class LinkedList {

            constructor(element) {
                this.count = 0
                this.head = null

            }

            push(element) {
                let node = new Node(element)

                if (this.head === null) {
                    this.head = node

                } else {
                    let current = this.head     //è¿™ä¸ªæ–°çš„å˜é‡æ˜¯ä¸ºäº†ä¿æŠ¤é“¾è¡¨çš„åŽŸå§‹headä¸å—æ”¹å˜ï¼Œä½†æ˜¯æŒ‡é’ˆæŒ‡å‘æœ€åŽçš„node
                    while (current.next !== null) {
                        current = current.next
                    }
                    current.next = node
                }
                this.count++

            }
            // æ‰¾åˆ°éœ€è¦ä½ç½®çš„nodeï¼ˆä»Žheadå¼€å§‹å¾€åŽæ‰¾ï¼‰
            getNodeAt(index) {
                if (index >= 0 && index < this.count) {
                    let node = this.head
                    for (let i = 0; i < index; i++) {
                        node = node.next
                    }
                    return node
                }

                return
            }

            //æŒ‡å®šä½ç½®åˆ é™¤(0,1,2ä½ç½®)
            removeAt(index) {
                if (index >= 0 && index < this.count) {
                    let current = this.head
                    if (index === 0) {
                        this.head = this.head.next
                    } else {
                        let previous = this.getNodeAt(index - 1)
                        current = previous.next
                        previous.next = current.next

                    }
                    this.count--

                    return current.element
                }
                return                       //è¿™é‡Œä¸å®šä¹‰ç›´æŽ¥è¿”å›ž undefined
            }


            indexOf(el) {

                let current = this.head
                for (let i = 0; i < this.count; i++) {
                    if (JSON.stringify(current.element) === JSON.stringify(el)) {            //å…ˆå°†å¯¹è±¡(obj)è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åŽæ¯”è¾ƒå­—ç¬¦ä¸².è¿™æ˜¯ä¸ºäº†é¿å…nodeä¸­å‚¨å­˜objectç±»åž‹çš„æ•°æ®ï¼Œå› ä¸ºobjectç±»åž‹çš„æ•°æ®æ— æ³•æ¯”è¾ƒ
                        return i
                    }
                    current = current.next

                }
                return -1
            }
            //åˆ é™¤ç»™å‡ºçš„å€¼
            remove(element) {
                let index = this.indexOf(element)
                return this.removeAt(index)


            }

            insert(element, index) {
                if (index >= 0 && index <= this.count) {   //æ³¨æ„è¿™ä¸ªindex<=this.countä¸­çš„ðŸŸ°ï¼Œè¡¨é¢æ’å…¥åœ¨ç©ºé›†åˆé‡Œé¢çš„ä¸€ä¸ªæ•°
                    const node = new Node(element)
                    if (index === 0) {
                        let current = this.head
                        node.next = current
                        this.head = node
                    } else {
                        let previous = this.getNodeAt(index - 1)
                        let current = previous.next
                        previous.next = node
                        node.next = current
                    }
                    this.count++
                    return true
                }
                return false
            }

           

            isEmpty() {
                return this.size() === 0
            }
            size() {
                return this.count
            }




        }
        let newList = new LinkedList()

        // é“¾è¡¨çš„è¿ç”¨------å›žæ–‡æ£€æŸ¥ï¼šå‰åŽè¯»éƒ½ä¸€æ ·

        function test(str) {
            let newStr = str.toLowerCase().split(' ').join('')
            let dequeue = new LinkedList()
            for (let i = 0; i < newStr.length; i++) {
                dequeue.push(newStr[i])
            }

            while (dequeue.size() > 1) {
                if (dequeue.removeAt(0) !== dequeue.removeAt(dequeue.size() - 1)) {

                    return false

                }
            }
            return true



        }
      //  console.log(test('w qq    W'))




    </script>
    <script>
        //è¿™æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨èŠ‚ç‚¹çš„ç±»å®šä¹‰ï¼Œç»§æ‰¿äº†æ™®é€šçš„å•å‘é“¾è¡¨èŠ‚ç‚¹
           class DoublyNode extends Node{
            constructor(element){
                super(element) //è°ƒç”¨çˆ¶ç±»çš„node 
                this.prev=null //æ–°å¢žï¼šæŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
            }
           }

           class DoublyLinkedList extends LinkedList{
            
            constructor(){
                 super()
                 this.tail=null

            }

            push(element){
                let node=new DoublyNode(element)
                if(this.head===null){
                    this.head=node
                    this.tail=node 
                }else{
                    this.tail.next=node
                    node.prev= this.tail
                    this.tail=node 


                }
                this.count++

            }
            insert(element,index){
                if(index>=0&&index<=this.count){
                    let node=new DoublyNode(element)
                    let current=this.head
                    if(index===0){
                        if(this.head===null){
                            this.head=node
                            this.tail=node

                        }else{
                            node.next=this.head
                            this.head.prev=node
                            this.head=node
                        }
                    }else if(index===this.count){
                        this.tail.next=node
                        node.prev=this.tail
                        this.tail=node

                       


                    }else{
                        let previous=this.getNodeAt(index-1)
                        current=previous.next

                        previous.next = node
                        node.prev=previous
                        node.next=current
                        current.prev=node
                        

                    }
                    this.count++
                    return true
                }
                return false
            }

            removeAt(index){
                if(index>=0&&index<this.count){
                    let current=this.head
                    if(index===0){
                        this.head=current.next
                        if(this.count===1){
                            this.tail=null

                        }else{
                            this.head.prev=undefined
                        }
                        this.head=this.head.next

                    }else if(index===this.count-1){
                        current=this.tail
                        this.tail=current.prev
                        this.tail.next=null
                    }else{
                        let previous=this.getNodeAt(index-1)
                        current= previous.next
                        previous.next=current.next
                        current.next.prev= previous

                    }

                 this.count--
                 return current.element
                }

            }







            getHead(){
                return this.head

            }
            getTail(){
                return this.tail

            }
           }

           let list= new DoublyLinkedList()
    </script>

</body>

</html>