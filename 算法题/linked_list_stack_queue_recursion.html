<!DOCTYPE html>
<html lang="en">

<head>
  <title>Web App</title>
  <style>
    
   
      
    
  </style>
</head>

<body>
  
  
  <script>
//æ¦‚å¿µ
//A->B->C->D->NULL
class LinkedList{
  constructor(value){
    this.value=value
    this.next=null
  }
}
let a=new LinkedList('A')
let b = new LinkedList('B')
let c = new LinkedList('C')
let d = new LinkedList('D')
a.next=b
b.next=c
c.next=d
//1.è¾“å‡ºæ¯ä¸ªnodeä¸­çš„æ¯ä¸ªvalueå€¼
//ç”¨while loopæ¥è¾“å‡ºvalueå€¼
// const printNodes=(head)=>{
//   let current=head
//   while(current!==null){
//     console.log(current.value)
//     current=current.next
//   }
// }
  //ç”¨recursionæ¥è¾“å‡ºvalueå€¼
  // const printRecursion=(head)=>{
  //   if(head===null){
  //     return
  //   }
  //   console.log(head.value)
  //   return printRecursion(head.next)
  // }

  // console.log(printRecursion(a))

//2.å°†linked listä¸­çš„æ‰€æœ‰node.valueæ”¾å…¥ä¸€ä¸ªarrayä¸­
//ç”¨while loopæ¥æ”¾å…¥arrayä¸­ï¼Œå‚è€ƒä¸Šè¿°å†…å®¹
  //ç”¨recursionæ¥æ”¾å…¥arrayä¸­
  // const linkedListValues=(head)=>{
  //   let arr=[]
  //   fillValues(head,arr)
  //   return arr
  // }
  // const fillValues=(head,arr)=>{
  //   if(head===null){
  //     return
  //   }
  //   arr.push(head.value)
  //   fillValues(head.next,arr)
  // }
  // console.log(linkedListValues(a))
//3.Sum List problem 

  let num = new LinkedList(1)
  let num2 = new LinkedList(2)
  let num3 = new LinkedList(3)
  let num4 = new LinkedList(4)
  num.next = num2
  num2.next = num3
  num3.next = num4
// while loop(time complexity--O(n) space complexity --O(1))
// const sumList=(head)=>{
//   let sum=0
//   let current=head
//   while(current!==null){
//     sum+=current.value
//     current=current.next
//   }
//   return sum
// }
// console.log(sumList(num))

  // recursion(time complexity--O(n) space complexity --O(n))
  // const sumRecursion = (head) => {
  //     if(head===null){
  //       return 0
  //     }

  //     return head.value+sumRecursion(head.next)

  //   }
  //   console.log(sumRecursion(num))
  //4.æ‰¾target value
  //iteration way (while loop) Time:O(n),Space:O(1)
  // const findValue=(head,val)=>{
  //   let current=head
  //   while(current!==null){
  //     if(current.value===val){
  //       return true
  //     }
  //     current=current.next
  //   }
  //   return false
  // }
  // console.log(findValue(a,'C'))
  //recursion Time:O(n),Space:O(n)
   const findRecurison = (head, val) => {
      if(head.value===null){
        return false
      }
      if(head.value===val){
        return true
      }
     
       return findRecurison(head.next,val)
      

    }
   
    console.log(findRecurison(a, 'C'))





    
//ä¸“é¢˜ä¸€ï¼šlist node
//1.give the head of a linked list,a new value,and an index to insert before, make a new node with the given value
//and insert it in the list before the given index.
//If the index <=0, the new node will be inserted at the head of the list.
//If the index >= the length of the existing list, the new node should be appended on the end of the list.
//Otherwise, the new node will be inserted into the list before the given index.
//The index is 0-based
//You will have to construct a new ListNode to hold the value
//å¤§è‡´çš„æ„æ€å°±æ˜¯è¯´åœ¨åŸå§‹çš„listed nodeçš„headï¼Œmiddleï¼Œtail ä¸­åŠ ä¸Šä¸€ä¸ª new node
//examples:

//head:1->2->3
//value:99
//index:1
//result:1->99->2->3

//head:1->2->3
//value:99
//index:0
//result: 99->1->->2->3

//head:1->2->3
//value:99
//index:293849
//result:1->2->3->293849

//head:null
//value:99
//index:any value
//result:99


// function ListNode(x){
//   this.value=x;
//   this.next=null
// }


   
//     function solution(head,value,index){
//        let n = new ListNode(value)
//        //situation 1: head:[]
//       if(head===null){
       
//         return n
//       }
//       //situation 2:index<=0
//       if(index<=0){
       
//         n.next=head
//         return n
//       }
//       //situation3: 0<index<list of length
//       //list:   1->2->3
//       //index:  0- 1 -2
//       let prev=head
//       let current=head.next
//       let cur_index=1
//       while(current!==null){
//         if(cur_index==index){
//               prev.next=n
//               n.next=current
//               //ä¹‹æ‰€ä»¥è¿”å›headæ˜¯å› ä¸ºpreå’ŒheadæŒ‡ä»£åŒä¸€ä¸ªobjectï¼Œæ‰€ä»¥preæ”¹å˜è¿™ä¸ªobject,head ä¹Ÿå°±è·Ÿç€æ”¹å˜
//               return head
//         }
//         prev=prev.next
//         current=current.next
//         cur_index++
//       }
      
//       //situation 4:index>list of length
//       //after the while loop, filter the situation 3(0<index<list of length) 
//       //current node became to the tail of list
//      prev.next=n
//      
//      return head
      
//     }
//    let h={value:1,next:{value:2,next:{value:3,next:null}}}
//    let h = { value: 1, next: null}
//     console.log(solution(h,99,79978))
//æ–¹æ³•2:
  // function ListNode(x) {
  //   this.value = x;
  //   this.next = null;
  // }

  // function solution(head, value, index) {
  //   let newNode = new ListNode(value);

  //   // å¦‚æœé“¾è¡¨ä¸ºç©ºæˆ–è€…è¦åœ¨ç´¢å¼•0å¤„æ’å…¥
  //   if (head === null || index <= 0) {
  //     newNode.next = head;
  //     const result = [];
  //     let current = newNode;
  //     while (current !== null) {
  //       result.push(current.value);
  //       current = current.next;
  //     }
  //     return result;
  //   }

  //   let prev = head;
  //   let current = head.next;
  //   let currentIndex = 1;

  //   while (current !== null) {
  //     if (currentIndex === index) {
  //       prev.next = newNode;
  //       newNode.next = current;
  //       return head;
  //     }

  //     prev = prev.next;
  //     current = current.next;
  //     currentIndex++;
  //   }

  //   // å¦‚æœ index å¤§äºé“¾è¡¨é•¿åº¦ï¼Œå°†æ–°èŠ‚ç‚¹æ·»åŠ åˆ°é“¾è¡¨æœ«å°¾
  //   prev.next = newNode;

  //   const result = [];
  //   let resultCurrent = head;
  //   while (resultCurrent !== null) {
  //     result.push(resultCurrent.value);
  //     resultCurrent = resultCurrent.next;
  //   }

  //   return result;
  // }



//2-----search by index 
//input :linked list  and the index
//output the related value in the index 
//éœ€è¦è·Ÿè¸ªcurrent index









  // function ListNode(x) {
  //   this.value = x;
  //   this.next = null
  // }
  // function solution(nodes, num) {

  //   let current = nodes
  //   let cur_index = 0
  //   while (current !== null) {
  //     if (cur_index === num) {
  //       return current.value

  //     } else {
  //       cur_index++
  //       current = current.next

  //     }
  //   }

  //   return current


  // }
  // let h = { value: 1, next: { value: 5, next: { value: 8, next: null } } }
  // console.log(solution(h, 2))
  //3-----search by value
//ä¸éœ€è¦è·Ÿè¸ªcurrent index



  // function ListNode(x) {
  //     this.value = x;
  //     this.next = null
  //   }
  //   function solution(nodes, v) {

  //     let current = nodes
      
  //     while (current !== null) {
  //       if (current.value === v) {
  //         return current

  //       } else {
          
  //         current = current.next

  //       }
  //     }

  //     return false


  //   }
  //   let h = { value: 1, next: { value: 5, next: { value: 8, next: null } } }
  //   console.log(solution(h, 5))

  //4------ insert a 9 after the 4
  //let h = { value: 3, next: { value: 4, next: { value: 0, next: null } } }

    // function ListNode(x) {
    //     this.value = x;
    //     this.next = null
    //   }
    //   function solution(nodes,x) {
    //     let pre=nodes
    //     let current = nodes.next
    //     let item=new ListNode(9)

    //     while (current !== null) {
    //       if (current.value === x) {
    //         pre.next=item
    //         item.next=current
    //         return nodes
    //       } else {
    //         current = current.next
    //         pre=pre.next

    //       }
    //     }
    //     pre.next=item

    //     return nodes


    //   }
    //   let h = { value: 3, next: { value: 4, next: { value: 0, next: null } } }
    //   console.log(solution(h,11))

   //5------ Linked List Deletes
  //  function ListNode(x) {
  //     this.value = x;
  //     this.next = null
  //   }
  //   function solution(nodes, x) {
  //     let pre = nodes
  //     let current = nodes.next
      

  //     while (current !== null) {
  //       if (current.value === x) {
  //         pre.next = current.next
         
  //         return nodes
  //       } else {
  //         current = current.next
  //         pre = pre.next

  //       }
  //     }
      

  //     return current


  //   }
  //   let h = { value: 3, next: { value: 4, next: { value: 0, next: null } } }
  //   console.log(solution(h, 11))

   //6------ Pop with a Linked list stack
   //first step:let old_head =head
   //second: head=head.next
   //third: old_head.next=null
   //return old_head  è¿™ä¸ªå°±æ˜¯popä¸‹æ¥çš„node

  //------------------ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨JavaScriptå®ç°ç»´æŠ¤å°¾æŒ‡é’ˆçš„é“¾è¡¨æ“ä½œçš„ç¤ºä¾‹ï¼š
  //maintaining a tail pointer
  // class ListNode {
  //   constructor(value) {
  //     this.value = value;
  //     this.next = null;
  //   }
  // }

  // class LinkedList {
  //   constructor() {
  //     this.head = null; // å¤´æŒ‡é’ˆ
  //     this.tail = null; // å°¾æŒ‡é’ˆ
  //   }

  //   // åœ¨é“¾è¡¨å°¾éƒ¨æ’å…¥å…ƒç´ 
  //   append(value) {
  //     const newNode = new ListNode(value);
  //     if (!this.head) {
  //       // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆå§‹åŒ–å¤´å°¾æŒ‡é’ˆéƒ½æŒ‡å‘æ–°èŠ‚ç‚¹
  //       this.head = newNode;
  //       this.tail = newNode;
  //     } else {
  //       // å¦åˆ™ï¼Œå°†æ–°èŠ‚ç‚¹è¿æ¥åˆ°å½“å‰å°¾éƒ¨èŠ‚ç‚¹çš„nextä¸Šï¼Œç„¶åæ›´æ–°å°¾æŒ‡é’ˆ
  //       this.tail.next = newNode;
  //       this.tail = newNode;
  //     }
  //   }

  //   // åœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥å…ƒç´ 
  //   prepend(value) {
  //     const newNode = new ListNode(value);
  //     if (!this.head) {
  //       // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œåˆå§‹åŒ–å¤´å°¾æŒ‡é’ˆéƒ½æŒ‡å‘æ–°èŠ‚ç‚¹
  //       this.head = newNode;
  //       this.tail = newNode;
  //     } else {
  //       // å¦åˆ™ï¼Œå°†æ–°èŠ‚ç‚¹é“¾æ¥åˆ°æ–°å¤´èŠ‚ç‚¹çš„nextä¸Šï¼Œç„¶åæ›´æ–°å¤´æŒ‡é’ˆ
  //       newNode.next = this.head;
  //       this.head = newNode;
  //     }
  //   }

  //   // åˆ é™¤é“¾è¡¨å°¾éƒ¨å…ƒç´ 
  //   deleteTail() {
  //     if (!this.head) {
  //       return; // ç©ºé“¾è¡¨ï¼Œæ— æ“ä½œ
  //     }

  //     if (this.head === this.tail) {
  //       // é“¾è¡¨åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå°†å¤´å°¾æŒ‡é’ˆéƒ½ç½®ä¸ºnull
  //       this.head = null;
  //       this.tail = null;
  //       return;
  //     }

  //     // éå†é“¾è¡¨æ‰¾åˆ°å€’æ•°ç¬¬äºŒä¸ªèŠ‚ç‚¹
  //     let current = this.head;
  //     while (current.next !== this.tail) {
  //       current = current.next;
  //     }

  //     // å°†å€’æ•°ç¬¬äºŒä¸ªèŠ‚ç‚¹çš„nextæŒ‡å‘nullï¼Œå¹¶æ›´æ–°å°¾æŒ‡é’ˆ
  //     current.next = null;
  //     this.tail = current;
  //   }

  //   // éå†é“¾è¡¨å¹¶è¿”å›ä¸€ä¸ªæ•°ç»„ï¼Œç”¨äºæ˜¾ç¤ºé“¾è¡¨çš„å†…å®¹
  //   toArray() {
  //     const result = [];
  //     let current = this.head;
  //     while (current) {
  //       result.push(current.value);
  //       current = current.next;
  //     }
  //     return result;
  //   }
  // }

  //project1:
  //For l1 = [1, 2, 3] and l2 = [4, 5, 6], the output should be
//     solution(l1, l2) = [1, 2, 3, 4, 5, 6];
// For l1 = [1, 1, 2, 4] and l2 = [0, 3, 5], the output should be
//     solution(l1, l2) = [0, 1, 1, 2, 3, 4, 5].


  // å®šä¹‰ä¸€ä¸ªè¡¨ç¤ºé“¾è¡¨èŠ‚ç‚¹çš„ç±»
  // class ListNode {
  //   constructor(value) {
  //     this.value = value; // èŠ‚ç‚¹çš„å€¼
  //     this.next = null;  // æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
  //   }
  // }

  // // å®šä¹‰ä¸€ä¸ªå‡½æ•°æ¥åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨
  // function mergeSortedLists(l1, l2) {
  //   // åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œç”¨äºç®€åŒ–é“¾è¡¨æ“ä½œ
  //   const dummyHead = new ListNode(-1);
  //   let current = dummyHead; // ç”¨äºè¿­ä»£çš„å½“å‰èŠ‚ç‚¹æŒ‡é’ˆ

  //   // éå†ä¸¤ä¸ªé“¾è¡¨ï¼Œæ¯”è¾ƒèŠ‚ç‚¹çš„å€¼å¹¶é€ä¸ªåˆå¹¶
  //   while (l1 !== null && l2 !== null) {
  //     if (l1.value < l2.value) {
  //       current.next = l1; // å°†l1èŠ‚ç‚¹è¿æ¥åˆ°åˆå¹¶åçš„é“¾è¡¨
  //       l1 = l1.next;     // ç§»åŠ¨l1æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
  //     } else {
  //       current.next = l2; // å°†l2èŠ‚ç‚¹è¿æ¥åˆ°åˆå¹¶åçš„é“¾è¡¨
  //       l2 = l2.next;     // ç§»åŠ¨l2æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
  //     }
  //     current = current.next; // ç§»åŠ¨åˆå¹¶åé“¾è¡¨çš„å½“å‰èŠ‚ç‚¹æŒ‡é’ˆ
  //   }

  //   // å°†å‰©ä½™çš„èŠ‚ç‚¹è¿æ¥åˆ°åˆå¹¶åçš„é“¾è¡¨æœ«å°¾
  //   if (l1 !== null) {
  //     current.next = l1;
  //   }
  //   if (l2 !== null) {
  //     current.next = l2;
  //   }

  //   // è¿”å›åˆå¹¶åçš„é“¾è¡¨ï¼Œè·³è¿‡è™šæ‹Ÿå¤´èŠ‚ç‚¹
  //   return dummyHead.next;
  // }

 //project2:
  //Input:
   // head == 1 -> 2 -> 3
  //Output: 3 -> 2 -> 1
  // Singly-linked lists are already defined with this interface:
    // function ListNode(x) {
    //   this.value = x;
    //   this.next = null;
    // }

    // function reverseLinkedList(head) {
    //   let prev = null;
    //   let current = head;

    //   while (current !== null) {
    //     let next = current.next; // Store the next node
    //     current.next = prev; // Reverse the next pointer

    //     // Move the pointers one step forward
    //     prev = current;
    //     current = next;
    //   }

    //   // The new head is the previous tail node
    //   return prev;
    // }

    // function solution(head) {
    //   if (head === null) {
    //     return head
    //   }
    //   return reverseLinkedList(head)

    // }
//project3:
    //For l = [1, 3, 4, 6] and value = 5, the output should be
    //       solution(l, value) = [1, 3, 4, 5, 6];
    // For l = [1, 3, 4, 6] and value = 10, the output should be
    //       solution(l, value) = [1, 3, 4, 6, 10];
    // For l = [1, 3, 4, 6] and value = 0, the output should be
    //       solution(l, value) = [0, 1, 3, 4, 6].
  // function solution(l, value) {
  //   let item = new ListNode(value);
  //   let head = l;
  //   let prev = null;

  //   // Handle the case where the list is empty
  //   if (l === null) {
  //     return item;
  //   }

  //   // Find the correct position to insert the new node
  //   while (l !== null && l.value <= value) {
  //     prev = l;
  //     l = l.next;
  //   }

  //   // If the new node should be inserted at the beginning
  //   if (prev === null) {
  //     item.next = head;
  //     return item;
  //   }

  //   // Insert the new node between prev and l
  //   prev.next = item;
  //   item.next = l;

  //   return head;
  // }

  // project 4: Queue +linked list
  //e--è¡¨ç¤ºenqueue  d---dequeue
  // ops: ["e 1", "e 2", "e 3"]

  // result: 1 -> 2 -> 3
  // ops: ["e 1", "e 2", "d", "e 3"]

  // result: 2 -> 3[Because 1 was dequeued]

 

  // class ListNode {
  //   constructor(value) {
  //     this.value = value;
  //     this.next = null;
  //   }
  // }

  // class LinkedListQueue {
  //   constructor() {
  //     this.head = null; // é˜Ÿåˆ—çš„å¤´éƒ¨
  //     this.tail = null; // é˜Ÿåˆ—çš„å°¾éƒ¨
  //   }

  //   // å…¥é˜Ÿæ“ä½œ
  //   enqueue(value) {
  //     const newNode = new ListNode(value);
  //     if (!this.head) {
  //       this.head = newNode;
  //       this.tail = newNode;
  //     } else {
  //       this.tail.next = newNode;
  //       this.tail = newNode;
  //     }
  //   }

  //   // å‡ºé˜Ÿæ“ä½œ
  //   dequeue() {
  //     if (!this.head) {
  //       return; // é˜Ÿåˆ—ä¸ºç©ºï¼Œæ— æ³•å‡ºé˜Ÿ
  //     }
  //     this.head = this.head.next;
  //     if (!this.head) {
  //       this.tail = null; // å¦‚æœå‡ºé˜Ÿåé˜Ÿåˆ—ä¸ºç©ºï¼Œæ›´æ–°å°¾éƒ¨
  //     }
  //   }

  //   // æ„å»ºé“¾è¡¨é˜Ÿåˆ—å¹¶æ‰§è¡Œæ“ä½œ
  //   buildQueueFromOperations(ops) {
  //     for (const operation of ops) {
  //       const [op, value] = operation.split(' ');
  //       if (op === 'e') {
  //         this.enqueue(parseInt(value)); // å…¥é˜Ÿæ“ä½œ
  //       } else if (op === 'd') {
  //         this.dequeue(); // å‡ºé˜Ÿæ“ä½œ
  //       }
  //     }
  //   }

  
  // }

  // function solution(nodes) {
  //   let queue = new LinkedListQueue()
  //   queue.buildQueueFromOperations(nodes)
  //   let lists = queue.head
  //   let arr = []
  //   while (lists !== null) {
  //     arr.push(lists.value)
  //     lists = lists.next

  //   }
  //   return arr
  // }

  //project 5: stack +linked list

  //Given a string sequence consisting of the characters '(',')','[',']','{','}'
//You task is to determine whether or not the sequence is a valid bracket sequence.
//The Valid bracket sequence is defined in the following way:
  //1.An empty bracket sequence is a valid bracket sequence--è¯´æ˜(),[],{}éƒ½æ˜¯valid
  //2.If s is a valid bracket sequence then (s),[s],{s} are also valid.---è¯´æ˜å°†valid åŒ…è£¹èµ·æ¥ï¼Œä¹Ÿæ˜¯valid
  //3.If A and B are valid bracket sequences then AB is also valid.--è¯´æ˜valid itemæ”¾åœ¨ä¸€èµ·ä¹Ÿæ˜¯valid
//examples:
//()-->true ; ()[]{}--->true ; ([])--->true
//(]--->false  ;([)]--->false
//éš¾ç‚¹ï¼Œå¹¶ä¸çŸ¥é“æœ‰å¤šå°‘çš„([{([{}])}])çš„ç»„åˆ
//æ–¹æ³•1:å°†["(","[","{"]æŒ‰ç…§å‡ºç°é¡ºåºå­˜åœ¨ä¸€ä¸ªarrayä¸­ï¼Œç„¶åå½“å‡ºç°')','}',']'çš„æ—¶å€™ï¼Œäºarrayä¸­æœ€åå‡ºç°çš„
//itemè¿›è¡Œmatchï¼Œå¦‚æœmatchä¸ä¸Šå°± falseï¼Œmatchä¸Šï¼Œå°±å°†arrayä¸­å¯¹åº”çš„itemåˆ æ‰ï¼Œåˆ åˆ°æœ€åï¼Œä¼šæ˜¯[]ã€‚
//å¦‚ä½•è¿˜å­˜åœ¨item in arrayï¼Œè¯´æ˜ä¸æ˜¯ä¸€ä¸€å¯¹åº”ï¼Œfalse
// function solution(sequence){
//   let arr=["(","[","{"]
//   let head=[]
//   let match={
//     ")":"(",
//     "]": "[",
//     "}": "{",
//   }
//  for (let i of sequence){
//   if(arr.includes(i)){
//     head.push(i)
//   }else{
//     if(match[i]===head.at(-1)){
//       head.pop()
//     }else{
//       console.log(head)
//       return false
//     }
    

//   }
//  }
 
//  console.log(head)
// //  if(head.length===0){
// //   return true
// //  }else{
// //    return false
// //  }
// //ä¸Šé¢å†…å®¹çš„ç®€å†™
// return head.length === 0
 

// }

// //console.log(solution("[()"))
// //æ–¹æ³•2:  create ä¸€ä¸ªclassï¼Œç„¶åæŒ‰ç…§ä¸Šä¸€ä¸ªæ–¹æ³•çš„æ€è·¯è¿›è¡Œä¿®æ”¹ 
//å¤„ç†ä¸€äº› last inï¼Œfirst out åè¿›ï¼Œå…ˆå‡ºçš„é—®é¢˜---- Stacks
//  class Stack{
//   constructor(){
//     this.stack=[]
//   }
//   push(x){
//     this.stack.push(x)
//   }
//   pop(){
//     return this.stack.pop()
//   }
//   //get length() ---length å±æ€§æ˜¯ä¸€ä¸ª getter æ–¹æ³•ï¼Œç”¨äºè·å–å †æ ˆä¸­å…ƒç´ çš„æ•°é‡
//   get length(){
//     return this.stack.length
//   }
//   isEmpty(){
//     return this.stack.length===0
//   }
//  }

//  function solution(sequence){
//   let origin=new Stack()
//   let arr = ["(", "[", "{"] 
//   let match = {
//     ")":"(",
//     "]": "[",
//     "}": "{",
//   }
//   for(let i of sequence){
//     if(arr.includes(i)){
//       origin.push(i)
//     }else{
//       item=origin.pop()
//       if(item!==match[i]){
//         return false
//       }

//       }
//     }
//     //return  origin.length === 0
//     //ğŸ‘†æ˜¯return length===0çš„ä¸€ç§æ–¹æ³•ï¼ŒğŸ‘‡æ˜¯å¦ä¸€ç§returnçš„length===0æ–¹æ³•
//     return origin.isEmpty()
//   }
//  console.log(solution("[)]"))

 //project 6: 
//You are given an array of requests, where requests[i] can be "push <x>" or "pop".
// Return an array composed of the results of each "pop" operation that is performed.
//For requests = ["push 1", "push 2", "pop", "push 3", "pop"], the output should be
//solution(requests) = [1, 2].After the first request, the queue is { 1 }; 
//after the second it is { 1, 2 }. Then we do the third request, "pop",
// and add the first element of the queue 1 to the answer array.The queue becomes { 2 }. 
//After the fourth request, the queue is { 2, 3 }. Then we perform "pop" again and 
//add 2 to the answer array, and the queue becomes { 3 }.
  // function solution(requests) {
  //     var left = [];
      

  //     function insert(x) {
  //       left.push(x)
  //     }

  //     function remove() {
  //       return left.shift()
  //     }

  //     ans = [];
  //     for (var i = 0; i < requests.length; i++) {
  //       var req = requests[i].split(" ");
  //       if (req[0] === "push") {
  //         insert(parseInt(req[1]));
  //       } else {
  //         ans.push(remove());
  //       }
  //     }
  //     return ans;
  //   }
  
//ä¸“é¢˜ä¸‰ï¼šRecursive Linked List Search
//Search a linked list for a value.Return true if the value was found
//examples:
//head:1->7->9
//value:2
//result:false





//æ–¹æ³•1:ç›´æ¥ç”¨listed node
// function ListNode(x){
//   this.value=x
//   this.next=null
// }

// function solution(head,v){
//    while(head.next!==null){
//     if(head.value===v){
//       return true
//     }else{
//       head=head.next
//     }

//    }
//    if(head.value === v){
//     return true
//    }else{
//     return false
//    }
  
// }

// let h = { value: 1, next: { value: 2, next: { value: 3, next: null } } }
// console.log(solution(h,4))

//æ–¹æ³•2: ç»“åˆrecursioné€’å½’ï¼›-----è¿”å›çš„æ˜¯ä¸‹ä¸€ä¸ªfunctionï¼ˆsearching the remainder of linked list)
  // function search(head,value){
  //   //head=== null å¹¶ä¸è¡¨ç¤º{ value: 3, next: null }ï¼Œæ‰€ä»¥è¿˜æ˜¯ä¼šåˆ°ä¸‹ä¸€æ­¥åˆ¤æ–­head.value===value
  //   //å¦‚æœæ‚¨è¦æ£€æŸ¥ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸ºé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œåªæœ‰å½“head.next===null
  //    if (head=== null ) {
  //     return false
  //   }
  //   if (head.value=== value) {
  //     return true
  //   }
   
  //   return search(head.next, value)
    
  // }

  // function solution(head,value) {
  //  return search(head,value)

  // }

  // let h = { value: 1, next: { value: 2, next: { value: 3, next: null } } }
  // console.log(solution(h, 3))

// function solution(x,count=0){

//   if(x>0){
//     count+=x
//     return solution(x-1,count)
//   }else{
//     return count
//   }
  
// }
// console.log(solution(5))

















  </script>

</body>

</html>