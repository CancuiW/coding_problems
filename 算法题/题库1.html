<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>


//练习1:
//     Given an array of integers a, your task is to count the number of pairs i and j(where 0 ≤ i < j < a.length),
// such that a[i] and a[j] are digit anagrams.

// Two integers are considered to be digit anagrams if they contain the same digits.In other words, 
//one can be obtained from the other by rearranging the digits(or trivially, if the numbers are equal). 
//For example, 54275 and 45572 are digit anagrams, but 321 and 782 are not(since they don't contain the same digits). 220 and 22 are also not considered as digit anagrams, 
//since they don't even have the same number of digits.

// For a = [25, 35, 872, 228, 53, 278, 872], the output should be solution(a) = 4.
     //a = [25, 35, 872, 228, 53, 278, 872]
// There are 4 pairs of digit anagrams:


//   a[1] = 35 and a[4] = 53(i = 1 and j = 4),
//   a[2] = 872 and a[5] = 278(i = 2 and j = 5),
//   a[2] = 872 and a[6] = 872(i = 2 and j = 6),
//   a[5] = 278 and a[6] = 872(i = 5 and j = 6
//思路：1，对array中的每个item进行验证，因为item中每个数字的顺序可以不一致，所以为了方便比较，就将item中的数字升序排列
//如果经过升序排列的item相同，说明找到了一对
//2，因为array中的原始item都是number，所以为了能将其中的数字（25）单独拿出来，必须用toString()method进行变换成字符串
//3.string-->array 才能使用.split（“”）
//4.["8","5"] sort((a,b)=>parseInt(a)-parseInt(b)) ----["5","8"]
  // function solve(x, y) {
  //   let item1 = x.toString().split("").sort((a,b)=>a-b).join("")
  //   let item2 = y.toString().split("").sort().join("")
  //   return (item1 === item2)
  // }

  // function solution(a) {
  //   let count = 0

  //   for (let i = 0; i < a.length - 1; i++) {

  //     for (let j = i + 1; j < a.length; j++) {
  //       if (solve(a[i], a[j])) {
  //         count++
  //       }
  //     }
  //   }
  //   return count

  // }
  //方法2
  //array.sort((a,b)=>a-b) 数字类型，升序排列，如果a-b>0,a排在b的后面，以此类推
  
   //num=25
  //  function change(num){
  //   const str=num.toString().split("").sort((a,b)=>a-b).join("")
  //   return str

  //  }
  //  function solution(arr){
  //   let arr2=arr.map(x=>change(x))
  //   let count=0
  //   for (let i=0;i<arr2.length;i++){
  //     for (let j=i+1 ;j<arr2.length;j++){
  //       if (arr2[i]===arr2[j]){
  //         count++

  //       }

  //     }
  //   }
  //   return count

  //  }
  //  a = [25, 35, 872, 228, 53, 278, 872]
  //  console.log(solution(a))
  


  //练习2
  
  

//   You are given an array of non - negative integers numbers.
//You are allowed to choose any number from this array and swap any two digits in it.
//If after the swap（交换） operation the number contains leading zeros,
// they can be omitted and not considered(eg: 010 will be considered just 10).

// Your task is to check whether it is possible to apply the swap operation at most once, 
//so that the elements of the resulting array are strictly increasing.


//       Example

// For numbers = [1, 5, 10, 20], the output should be solution(numbers) = true.

// The initial array is already strictly increasing, so no actions are required.


// For numbers = [1, 3, 900, 10], the output should be solution(numbers) = true.

// By choosing numbers[2] = 900 and swapping its first and third digits, the resulting number 009 is considered to be just 9. So the updated array will look like[1, 3, 9, 10], which is strictly increasing.

// For numbers = [13, 31, 30], the output should be solution(numbers) = false.

// The initial array elements are not increasing.
// By swapping the digits of numbers[0] = 13, the array becomes[31, 31, 30] which is not strictly increasing;
// By swapping the digits of numbers[1] = 31, the array becomes[13, 13, 30] which is not strictly increasing;
// By swapping the digits of numbers[2] = 30, the array becomes[13, 31, 3] which is not strictly increasing;
//     So, it's not possible to obtain a strictly increasing array, and the answer is false.
//
//思路：
//1，因为最开始需要验证一次是array中是否是升序排列，等改变操作完成后还需要验证一次，所以单独做一个验证升序的function
//2，如何original array是升序，return true，如何不是，则找出最大值是多少，且在哪个位置（index）
//也可以用for loop找到下一个比上一个小或者相等的值，，得到这个特殊值的value和index，带入change function
//3，再将最大值进行单独的处理，将其变成array的形式后，对第一个数与最后一个互换，形成新的数字
//再将新的数字替换original array中 同位置index的最大值
//最后对新的array再次检测是否升序，如果仍旧不是，才能return false
//注意：：如果要对array中的内容进行互换，则临时需要一个中间值medium来帮助储存数据
// function increase(arr){
//   for (let i=0;i<arr.length;i++){
//     if(arr[i+1]<=arr[i]){
//       return false
//     } 
//   }
//   return true
// }



// function solution(numbers){
//   if (increase(numbers)){
//     return true
//   }else{
//     let maxValue=Math.max(...numbers)//Math.max（）只引导一串数字，不能是array （1，2，3，4）可以，【1，2，3，4】不行
//     let indexOfMax=numbers.indexOf(maxValue)//找出index，为最后用splice（）进行调换做准备
//     let arrayMax=maxValue.toString().split("")

//     let first= arrayMax[0]//这三排是对array中第一和最后一位数进行互换
//     arrayMax[0]= arrayMax[arrayMax.length - 1]
//     arrayMax[arrayMax.length - 1]=first

//     let change= arrayMax.join("")
//       change=parseInt(change)//新的数字仍旧是string的形式，所以要转换成number形式
//       numbers.splice(indexOfMax,1,change)
//       if(increase(numbers)){
//         return true
//       }else{
//         return false
//       }

    
//   }

// }

// const a=solution([1000, 10, 100])
// console.log(a)
//方法2
  // let numbers = [1, 2, 300, 3]
  // function increase(arr) {
  //   for (let i = 0; i < arr.length; i++) {
  //     if (arr[i + 1] <= arr[i]) {
  //       return false
  //     }
  //   }
  //   return true


  // }
  //console.log(increase(numbers))
  //

  // function changeNum(num) {
  //   const arr = num.toString().split("")
  //   let medium = arr[0]
  //   arr[0] = arr.at(-1)
  //   arr[arr.length - 1] = medium
  //   return parseInt(arr.join(""))

  // }
  // // console.log(changeNum(900))
  // function solution(arr) {
  //   if (increase(arr)) {
  //     return true
  //   } else {
  //     for (let i = 0; i < arr.length; i++) {
  //       if (arr[i + 1] <= arr[i]) {
  //         let item = changeNum(arr[i])
  //         arr.splice(i, 1, item)
  //       }
  //     }
  //     if (increase(arr)) {
  //       return true
  //     } else {
  //       return false
  //     }

  //   }
  // }
  // console.log(solution(numbers))
  
//以下测试数据
//numbers: [1, 5, 10, 20] true 
//numbers: [1, 3, 900, 10] true



//num = ['hello', 'love', 'favorite']
//'h e l l o'

//练习3:
    //将array中的所有元素中的vowel（元音字母）大写
  

//方法1
  // function change(item) {
  //   return item.split("").map(x => {
  //     if (x === "a" || x === "e" || x === "i" || x === "o" || x === "u"
  //     ) {
  //       return x.toUpperCase()
  //     } else {
  //       return x
  //     }
  //   }).join("")

  // }


  // function solution(num) {
  //   return num.map(x => change(x))

  // }
  // let a = ['hello', 'love', 'favorite']
  // console.log(solution(a))

//方法2:

  // let number = ['hello', 'love', 'favorite']
  // //let item="hello"
  // function change(str) {
  //   const arr = str.split("")
  //   const vowels = ["a", "e", "i", "o", "u"]
  //   const result = []
  //   for (let i = 0; i < arr.length; i++) {
  //     if (vowels.includes(arr[i])) {
  //       const char = arr[i].toUpperCase()
  //       result.push(char)
  //     } else {
  //       result.push(arr[i])
  //     }
  //   }
  //   return result.join("")


  // }
  // //console.log(change(item))



  // function solution(arr) {
  //   let result = arr.map(x => change(x))
  //   return result

  // }
  // console.log(solution(number))


  // function binary(num){
  //   let string=num.toString(2)
  //   return string.padStart(8,"0")


  // }
  
  // function solution(arr){
  //   let newArr=arr.map(x=>binary(x))
   
  //   let newStr=""
  //   for(let i=newArr.length-1;i>=0;i--){
  //     newStr+=newArr[i]

  //   }
  //   return parseInt(newStr,2)


  // }
  // let a = [24, 85, 0]
  //   console.log(solution(a))

//练习4


//For a = [24, 85, 0], the output should be  solution(a) = 21784.
// An array[24, 85, 0] looks like[00011000, 01010101, 00000000] in binary.
// After packing these into one number we get 00000000 01010101 00011000(spaces are placed for convenience), which equals to 21784.
//就是将array中的每一项全部变成2进制，且且8位数，然后从后往前将array中的内容相连成1个string，再对这个重组的string变成10进制
 
//  function binary(num) {
  //     let string = num.toString(2)
  //     return string.padStart(8, "0")


  //   }

  //   function solution(arr) {
  //     let newArr = arr.map(x => binary(x))

  //     let newStr = ""
  //     for (let i = newArr.length - 1; i >= 0; i--) {
  //       newStr += newArr[i]

  //     }
  //     return parseInt(newStr, 2)


  //   }
  //   let a = [24, 85, 0]
  //   console.log(solution(a))

//方法2:
// function change(num){
//   const binary=num.toString(2)
//   const result=binary.padStart(8,"0")
//   return result

// }
// //console.log(change(24))
// function solution(arr){
//   let array=arr.map(x=>change(x)).reverse()
//   let result=array.reduce((a,b)=>a+b,0)
//   let number=parseInt(result,2)
//   return number

// }
// console.log(solution([24, 85, 0]))


  //1，You are given a two-digit integer n. Return the sum of its digits.

  //For n = 29, the output should be  solution(n) = 11.
  
  //  function solution(n) {
  //     let ten = Math.floor(n / 10);
  //     let num = n % 10;
  //     console.log(num)
  //     return ten + num


  //   }
  //source = "amazing"
  // function change(str){
  //   let arr=str.split("")
  //   let newArr=""
  //   for (let i in arr){
  //     if (arr[i]==="a"|| arr[i] === "e" || arr[i] === "i" || arr[i] === "o" || arr[i] === "u" || arr[i] === "y" ){
  //       newArr+=0
  //     }else{
  //       newArr+=1
  //     }
  //   }
  //   return newArr


  // }

  // function solution(pattern,source) {
  //   let newArr=[]
  //   let string= change(source)
  //   for(let i=0;i<string.length-2;i++){
  //     let item=string.slice(i,i+3)
  //     newArr.push(item)
  //   }
  
  //  let count=0
  //  for (let i in newArr){
  //   if (newArr[i]===pattern){
  //     count++

  //   }
  //  }
  //  return count


  // }
  

  
  
  // 练习5:

  //     You are given two strings - pattern and source.The first string pattern contains only the symbols 0 and 1,
  // and the second string source contains only lowercase English letters.

//         Let's say that pattern matches a substring source[l..r] of source if the following three conditions are met:

// they have equal length,
// for each 0 in pattern the corresponding letter in the substring is a vowel,
// for each 1 in pattern the corresponding letter is a consonant.
// Your task is to calculate the number of substrings of source that match pattern.

//         Note: In this task we define the vowels as 'a', 'e', 'i', 'o', 'u', and 'y'.All other letters are consonants.

//           Example


// For pattern = "010" and source = "amazing", the output should be solution(pattern, source) = 2.
    // function change(str) {
    //     let arr = str.split("")
    //     let newArr = ""
    //     for (let i in arr) {
    //       if (arr[i] === "a" || arr[i] === "e" || arr[i] === "i" || arr[i] === "o" || arr[i] === "u" || arr[i] === "y") {
    //         newArr += 0
    //       } else {
    //         newArr += 1
    //       }
    //     }
    //     return newArr


    //   }

    //   function solution(pattern, source) {
    //     let newArr = []
    //     let string = change(source)
    //     for (let i = 0; i < string.length - 2; i++) {
    //       let item = string.slice(i, i + 3)
    //       newArr.push(item)
    //     }

    //     let count = 0
    //     for (let i in newArr) {
    //       if (newArr[i] === pattern) {
    //         count++

    //       }
    //     }
    //     return count


    //   }

    //   console.log(solution("010", "amazing"))
//方法2
    // function changes(letter) {

    //     let vowels = ['a', 'e', 'i', 'o', 'u', 'y']
    //     let arr = letter.split('')
    //     return arr.map(x => vowels.includes(x) ? '0' : '1').join('')

    //   }
    //   function solution(pattern, source) {
    //     let newSource = changes(source)
    //     let leng = pattern.length
    //     let res = []
    //     for (let i = 0; i < newSource.length - leng + 1; i++) {
    //       let part = newSource.slice(i, i + leng)
    //       res.push(part)
    //     }
    //     let numbers = 0
    //     for (let j of res) {
    //       if (pattern === j) {
    //         numbers++
    //       }
    //     }
    //     return numbers


    //   }
    //   console.log(solution('010', 'amazing'))

    //练习6
 

//      You are given an array of integers a, where each element a[i] represents the length of a ribbon.

// Your goal is to obtain k ribbons of the same length, by cutting the ribbons into as many pieces as you want.

// Your task is to calculate the maximum integer length L for which it is possible to obtain at least k ribbons of length L by cutting the given ones.

// Here's a way to achieve 5 ribbons of length 4:

// Cut the ribbon of length 5 into one ribbon of length 1(which can be discarded) and one ribbon of length 4.
// Cut the ribbon of length 7 into one ribbon of length 3(which can be discarded) and one ribbon of length 4.
// Use the existing ribbon of length 4(no need to cut it)
// Cut the ribbon of length 9 into two ribbons of length 4(and one of length 1 which can be discarded)
// Discard the ribbon of length 2.
// And since it wouldn't be possible to make 5 ribbons of any greater length, the answer is 4.

// For a = [1, 2, 3, 4, 9] and k = 6, the output should be solution(a, k) = 2.



// Here's one way we could make 6 ribbons of length 2:

// Cut the ribbon of length 9 into four ribbons of length 2 and one ribbon of length 1(which won't be used).
// Cut the ribbon of length 4 into two ribbons of length 2.
// Ignore all other ribbons(1, 2, and 3).Even though ribbons with lengths 2 and 3 can also be used to obtain the ribbon of length 2, we don't need more than 6 ribbons of that length.
// It would technically be possible to make 6 ribbons of a length as great as 2.25, but since only integer values are allowed, the answer is 2.
  //意思就是说，最少得到6个same的片段，保证小片段的长度最大
    
//思路：要搞清楚在提供的array中的最大值，从假设以长度为1m来切割，到array中的最大值
//并将每次切割后得到的数量与题目要求的K值相比较（只要>=k）就可以，并放在一个空array【】中。
//找出这个array中的最大值
//然后
//  function solution(a, k) {

//     let max = Math.max(...a)
//     let i = 1
//     let total = []
//     while (i <= max) {
//       let innerNum = 0
//       for (let j of a) {
//         let divition = Math.floor(j / i)
//         if (divition > 0) {
//           innerNum += divition
//         }
//       }
//       if (innerNum >= k) {
//         total.push(i)
//       }
//       i++
//     }
//     return total.pop()

  //}
//方法2:
//let a = [1, 2, 3, 4, 9] and k = 6,

    // function solution(arr,k){
    //   let minArr=Math.min(...arr)
    //   let maxArr=Math.max(...arr)
    //   let newArr=[]
    //   for(let i=minArr;i<=maxArr;i++){
    //     newArr.push(i)
    //   }
      
    //   //newArr=[1, 2, 3, 4, 5, 6, 7, 8, 9]
    //   //arr = [1, 2, 3, 4, 9]
    //   let results=[]
    //   for(let j=0;j<newArr.length;j++){
    //     let count = 0
    //     for(let z=0;z<arr.length;z++){
    //       if(arr[z]>=newArr[j]){
    //         let num= Math.floor(arr[z]/ newArr[j])
    //         count+=num

    //       }
    //     }
    //     if(count>=k){
    //       results.push(newArr[j])
    //     }
    //   }
    //   return Math.max(...results)
    // }
    // console.log(solution([1, 2, 3, 4, 9],6))
    //方法3:
    // let a = [1, 2, 3, 4, 9]
    //   let k = 6

    //   function solution(a, k) {
    //     let big = Math.max(...a)
    //     let small = Math.min(...a)

    //     for (let i = big; i >= small; i--) {
    //       let inner = 0
    //       for (let j = a.length - 1; j >= 0; j--) {
    //         let num = Math.floor(a[j] / i)
    //         inner += num
    //       }
    //       if (inner >= k) {
    //         return i
    //       }
    //     }

    //   }


    //   console.log(solution(a, k))
   
 //  Tests passed: 25 / 32. Execution time limit exceeded on test 26: Program exceeded the execution time limit.Make sure that it completes execution in a few seconds for any possible input. 
 //方法4：
//  function solution(a, k) {
//     let maxItem = Math.max(...a)
//     let res = []
//     for (let i = 1; i <= maxItem; i++) {
//       let sum = 0
//       for (let j = 0; j < a.length; j++) {
//         let num = Math.floor(a[j] / i)
            

//         sum += num
//       }
//       if (sum >= k) {
//         res.push(i)
//       }
//     }
//     return Math.max(...res)

//   }
//   let a = [1, 2, 3, 4, 9]
//   let k = 6
//   console.log(solution(a, k))


  
//console.log(solution("3880282", "111111", "499139"));
  //练习8:
    //solution(firstNum, secondNum,finalNum)
    //3个string，任意删除第一个string中的一个element，得到的string变成number与secondNum相加，是否能得到finalNum,
    //如果能得到，返回能得到的总数
    //solution("3880282","111111","499139") --->1

    // function solution(firstNum, secondNum, finalNum) {
    //   let count = 0
    //   let first = []
    //   let second = parseInt(secondNum)
    //   let final = parseInt(finalNum)

    //   for (let i = 0; i < firstNum.length; i++) {
    //     let item = firstNum.slice(0, i) + firstNum.slice(i + 1)
    //     first.push(item)
    //   }
    //   //console.log(first)
    //   for (let j = 0; j < first.length; j++) {
    //     let num = parseInt(first[j])
    //     if (num + second === final) {
    //       count++
    //     }

    //   }
    //   return count




    // }
//练习9:


    //---code arcode 22 题 ‘swap adjacent bits’
     //You're given an arbitrary 32-bit integer n. Take its binary representation, 
     //split bits into it in pairs (bit number 0 and 1, bit number 2 and 3, etc.) 
     //and swap bits in each pair. Then return the result as a decimal number.
//For n = 13, the output should be
//   solution(n) = 14.

//   1310 = 11012 ~> { 11}{01 } 2 ~> 11102 = 1410.

// For n = 74, the output should be
//   solution(n) = 133.
//意思：if binary 是奇数，则在开头加“0”，最后加2，如果是偶数，只在最后加2
//   7410 = 010010102 ~> {01}{00 } { 10 } { 10 } 2 ~> 100001012 = 13310.
// Note the preceding zero written in front of the initial number: since both numbers are 32 - bit integers,
// they have 32 bits in their binary representation.The preceding zeros in other cases don't matter, so they are omitted. Here, however, it does make a difference.
  //注意，发现例子中所有的二进制数都是偶数位的长度，所以可以先将原先的二进制变成偶数的length再进行元素之间的交换  
  //  function changeNum(num) {
  //     const str = num.toString(2)

  //     const evenOrOdd = str.length % 2
  //     if (evenOrOdd === 0) {
  //       let even = str
  //       return even
  //     } else {
  //       let odd = "0" + str
  //       return odd
  //     }


  //   }
  //   //console.log(changeNum(13));
  //   //number='11012'
  //   function solution(num) {
  //     const str = changeNum(num)
  //     console.log(str);
  //     const arr = []
  //     for (let i = 0; i < str.length; i += 2) {
  //       const item = str.slice(i, i + 2)
  //       arr.push(item)
  //     }
  //     //arr=['11', '01']
  //     //console.log(arr);
  //     const reverseItem = arr.map(x => x.split("").reverse().join(""))
  //     result = reverseItem.join("") + "2"
  //     outcome = parseInt(result, 2)
  //     return outcome
  //   }

  //   console.log(solution(13));

//练习10:


//Different Rightmost Bit

//You're given two integers, n and m. Find position of the rightmost bit in which they differ 
//in their binary representations (it is guaranteed that such a bit exists), counting from right to left.
//  For n = 11 and m = 13, the output should be
//   solution(n, m) = 2.
//   11---1011    13--1101
//   1110 = 10112, 1310 = 11012, the rightmost bit in which they differ is the bit at position 1(0 - based)
// from the right in the binary representations.
// So the answer is 21 = 2.

// For n = 7 and m = 23, the output should be
//   solution(n, m) = 16. 
//710 = 1112, 2310 = 101112     
 //00111 10111
 //So the answer is 24 = 16

 //function solution(n, m) {
//   let first=n.toString(2)
//   let second=m.toString(2)
  
//   let multiFirst=first.padStart(32,"0")
//   let multiSecond=second.padStart(32,"0")
//   //console.log(multiFirst) 00000000000000000000000000001011
//   //console.log(multiSecond)00000000000000000000000000001101
//   let index=0
//   for (let i=multiFirst.length-1; i>=0;i--){
    
//       if (multiFirst[i]!==multiSecond[i]){
          
//           return 2**(31-i)
//       }
    
//   } 
// }

//练习11:
// Count Sum of Two Representations 2
//Given integers n, l and r, find the number of ways to represent n as a sum of two integers A and B such that l ≤ A ≤ B ≤ r.
// For n = 6, l = 2, and r = 4, the output should be
//   solution(n, l, r) = 2.
//2，3，4


  
// There are just two ways to write 6 as A + B, where 2 ≤ A ≤ B ≤ 4: 6 = 2 + 4 and 6 = 3 + 3.
  //方法1:但是hidden的test没过关，但是思路可以借鉴
  // function array(l, r){
  //   const arr = []
  //   for (let i = l; i <= r; i++) {
  //     arr.push(i)

  //   }
  //   return arr
  // }
  //   // console.log(array(2,4))
  //   function solution(n, l, r) {
  //     const arr = array(l, r)
  //     let count = 0
  //     for (let i = 0; i < arr.length; i++) {
  //       for (let j = i; j < arr.length; j++) {
  //         if (arr[i] + arr[j] === n) {
  //           count++
  //         }
  //       }
  //     }
  //     return count
  //   }
  //   console.log(solution(6, 2, 4))
  //方法2，用n减去最小的一个数字，那么另一个数字一定就在i<另一个数<r 的区间里面
  //如果存在就count+1
  // function solution(n, l, r) {
  //   var count = 0;

  //   for (let i = l; i <= r; i++) {
  //     var b = n - i;
  //     if (b >= i && b <= r) {
  //       count++;
  //     }
  //   }

  //   return count;
  // }

 //练习12:
//"ab12c"

 
 //Given two strings s and t, both consisting of lowercase English letters and digits, 
 //your task is to calculate how many ways exactly one digit could be removed from one of the strings
 // so that s is lexicographically smaller than t after the removal.Note that we are removing only 
 //a single instance of a single digit, rather than all instances(eg: removing 1 from the string a11b1c 
 //could result in a1b1c or a11bc, but not abc).
//For s = "ab12c" and t = "1zz456", the output should be solution(s, t) = 1.

// Here are all the possible removals:

// We can remove the first digit from s, obtaining "ab2c". "ab2c" > "1zz456", so we don't count this removal
// We can remove the second digit from s, obtaining "ab1c". "ab1c" > "1zz456", so we don't count this removal
// We can remove the first digit from t, obtaining "zz456". "ab12c" < "zz456", so we count this removal
// We can remove the second digit from t, obtaining "1zz56". "ab12c" > "1zz56", so we don't count this removal
// We can remove the third digit from t, obtaining "1zz46". "ab12c" > "1zz46", so we don't count this removal
// We can remove the fourth digit from t, obtaining "1zz45". "ab12c" > "1zz45", so we don't count this removal
//以下是解决问题的步骤：

// 初始化计数器 count 为 0，用于记录满足条件的移除方式的数量。
// 遍历字符串 s 的每个字符：
//   a.如果当前字符是一个数字字符：
// 在 s 中移除当前数字字符，得到新的字符串 newS。
// 比较 newS 和 t 的大小，如果 newS 小于 t，则计数器 count 加1。
// 恢复 s 的原始状态，以便尝试下一个位置上的数字字符。
//   b.如果当前字符不是数字字符，则继续下一个字符的处理。
// 遍历字符串 t 的每个字符：
//   a.如果当前字符是一个数字字符：
// 在 t 中移除当前数字字符，得到新的字符串 newT。
// 比较 s 和 newT 的大小，如果 s 小于 newT，则计数器 count 加1。
// 恢复 t 的原始状态，以便尝试下一个位置上的数字字符。
//   b.如果当前字符不是数字字符，则继续下一个字符的处理。
// 返回计数器 count 的值，即满足条件的移除方式的数量。
  // function solution(s, t) {
  //   let count = 0;

  //   for (let i = 0; i < s.length; i++) {
  //     if (isDigit(s[i])) {
  //       let newS = removeCharacterAtIndex(s, i);
  //       if (newS < t) {
  //         count++;
  //       }
       
  //     }
  //   }

  //   for (let i = 0; i < t.length; i++) {
  //     if (isDigit(t[i])) {
  //       let newT = removeCharacterAtIndex(t, i);
  //       if (s < newT) {
  //         count++;
  //       }
        
  //     }
  //   }

  //   return count;
  // }

  // function isDigit(char) {
  //   return /\d/.test(char);
  // }

  // function removeCharacterAtIndex(str, index) {
  //   return str.slice(0, index) + str.slice(index + 1);
  // }

  // // 测试示例
  // const s = "ab12c";
  // const t = "1zz456";
  // const result = solution(s, t);
  // console.log(result); // 输出：1
  //方法2
  // function solution(s, t) {
  //   let count = 0
  //   for (let i = 0; i < s.length; i++) {

  //     if (parseInt(s[i]) >= 0) {
  //       let newS = s.slice(0, i) + s.slice(i + 1)
  //       if (newS < t) {
  //         count++
  //       }
  //     }
  //   }
  //   for (let j = 0; j < t.length; j++) {

  //     if (parseInt(t[j]) >= 0) {
  //       let newT = t.slice(0, j) + t.slice(j + 1)
  //       if (s < newT) {
  //         count++
  //       }
  //     }
  //   }
  //   return count
  // }
  // let s = "ab21c"
  // let t = "1zz456"
  // console.log(solution(s, t))
  //练习13:
  //Given an array of integers a, your task is to find how many of its contiguous subarrays of length m contain a pair of integers with a sum equal to k.

// More formally, given the array a, your task is to count the number of indices 0 ≤ i ≤ a.length - m such that a subarray[a[i], a[i + 1], ..., a[i + m - 1]] contains at least one pair(a[s], a[t]), where:

//     s ≠ t
//     a[s] + a[t] = k
//For a = [2, 4, 7, 5, 3, 5, 8, 5, 1, 7], m = 4, and k = 10, the output should be solution(a, m, k) = 5.

// Let's consider all subarrays of length m = 4 and see which fit the description conditions:

// Subarray a[0..3] =[2, 4, 7, 5] doesn't contain any pair of integers with a sum of k = 10. Note that although the pair (a[3], a[3]) has the sum 5 + 5 = 10, it doesn't fit the requirement s ≠ t.
// Subarray a[1..4] =[4, 7, 5, 3] contains the pair(a[2], a[4]), where a[2] + a[4] = 7 + 3 = 10.
// Subarray a[2..5] =[7, 5, 3, 5] contains two pairs(a[2], a[4]) and(a[3], a[5]), both with a sum of k = 10.
// Subarray a[3..6] =[5, 3, 5, 8] contains the pair(a[3], a[5]), where a[3] + a[5] = 5 + 5 = 10.
// Subarray a[4..7] =[3, 5, 8, 5] contains the pair(a[5], a[7]), where a[5] + a[7] = 5 + 5 = 10.
// Subarray a[5..8] =[5, 8, 5, 1] contains the pair(a[5], a[7]), where a[5] + a[7] = 5 + 5 = 10.
// Subarray a[6..9] =[8, 5, 1, 7] doesn't contain any pair with a sum of k = 10.
// So the answer is 5, because there are 5 contiguous subarrays that contain a pair with a sum of k = 10.

  //For example, consider arr = [2, 3, 7]:

  // [3, 7] is a contiguous subarray of arr
  // [2, 3, 7] is a contiguous subarray of arr
  // [7] is a contiguous subarray of arr
  // [1, 2, 3] is not a contiguous subarray because it contains elements not in arr
  // [2, 7] is not a contiguous subarray because the elements aren't adjacent in arr

  //4个一一个array，并检查其中是否含有两个数相加=k,有count+=1
  //[4, 7, 5, 3]
  //[4, 7, 5, 3]
  // function exist(arr, k) {
  //   for (let i = 0; i < arr.length - 1; i++) {
  //     for (let j = i + 1; j < arr.length; j++) {
  //       if (arr[i] + arr[j] === k) {
  //         return true
  //       }
  //     }
  //   }
  //   return false
  // }




  // function solution(a, m, k) {
  //   let count = 0
  //   let wholeArr = []
  //   for (let i = 0; i < a.length - m + 1; i++) {
  //     let item = a.slice(i, i + m)
  //     wholeArr.push(item)

  //   }
  //   for (let i in wholeArr) {
  //     if (exist(wholeArr[i], k)) {
  //       count++
  //     }
  //   }
  //   return count

  // }
  //练习13:
//For a given string, return the letter that's highest in the alphabet.
//s == "eniac" ==>"n"

  //function solution(str) {
    // if (str.length === 0) {
    //   return ''; // Return an empty string for an empty input
    // }

    // let highest = str[0]; // Assume the first character is the highest

    // for (let i = 1; i < str.length; i++) {
    //   if (str[i] > highest) {
    //     highest = str[i];
    //   }
    // }

//     return highest;
// }
//方法2:
  // function solution(char) {
  //   let newArr = char.split('').map(x => x.charCodeAt(0))
  //   let num = Math.max(...newArr)
  //   return String.fromCharCode(num)
  // }
  // console.log(solution("eniac"))


//练习14
//Given an array of integers a, your task is to calculate the digits that occur the most number of times in the array
//.Return the array of these digits in ascending order.

// Example


 


//For a = [25, 2, 3, 57, 38, 41], the output should be solution(a) = [2, 3, 5].
//Here are the number of times each digit appears in the array:

  // 0 -> 0
  // 1 -> 1
  // 2 -> 2
  // 3 -> 2
  // 4 -> 1
  // 5 -> 2
  // 6 -> 0
  // 7 -> 1
  // 8 -> 1
//The most number of times any number occurs in the array is 2, and the digits which appear 2 times are 2, 3 and 5.
// So the answer is[2, 3, 5].
  //最多的是出现2次
  //有数字出现过2次，升序排列，返回array

  

// function change(arr){
//   let newString=""
//   for (let i in arr){
//     let item=arr[i].toString()
//     newString+=item
//   }
//   return newString.split("")

// }
// //console.log(change(a))---->['2', '5', '2', '3', '5', '7', '3', '8', '4', '1']
// function solution(arr){
//   let newArr=change(arr)
//   let obj={}
//   for (let j of newArr ){
//     if (j in obj){
//       obj[j]++
//     }else{
//       obj[j]=1
//     }
//   }
//   //obj--->{1: 1, 2: 2, 3: 2, 4: 1, 5: 2, 7: 1, 8: 1}
//   let values=Object.values(obj)
//   let max=Math.max(...values)
//   let res=[]
//   for (let k in obj){
//     if(obj[k]===max){
//       res.push(k)
//     }
//   }
//   return res
// }

//   console.log(solution(a))

  
  // }
  //练习15
//   You've created a new programming language, and now you've decided to add hashmap support to it.
//Actually you are quite disappointed that in common programming languages it's impossible to 
//add a number to all hashmap keys, or all its values. So you've decided to take matters into your own hands 
//and implement your own hashmap in your new language that has the following operations:

// insert x y - insert an object with key x and value y.    insert ---> {x:y}
// get x - return the value of an object with key x.        get x  --->  y
// addToKey a - add a to all keys in map.                addToKey a -->  {x+a:y}
// addToValue y - add y to all values in map.          addToValue a -->  {a:y+a}
// To test out your new hashmap, you have a list of queries in the form of two arrays: 
//queryTypes contains the names of the methods to be called(eg: insert, get, etc), 
//and queries contains the arguments for those methods(the x and y values).


//注意：key 的形式为string，所以每次需要注意其type的变化

  // Number() 可以处理小数和科学记数法，例如 Number("3.14") 会返回 3.14，而 Number("1e3") 会返回 1000。
  // parseInt() 会忽略小数点及其后的内容，例如 parseInt("3.14") 会返回 3，而 parseInt("1e3") 会返回 1。

  

// Your task is to implement this hashmap, apply the given queries, and to find the sum of all the results 
//for get operations.

// Example
 
// For queryType = ["insert", "insert", "addToValue", "addToKey", "get"] and 
//         query = [[1, 2], [2, 3], [2], [1], [3]], the output should be solution(queryType, query) = 5.

// The hashmap looks like this after each query:

//     1 query: { 1: 2 }
//     2 query: { 1: 2, 2: 3 }
//     3 query: { 1: 4, 2: 5 }
//     4 query: { 2: 4, 3: 5 }
//     5 query: answer is 5
// The result of the last get query for 3 is 5 in the resulting hashmap.
//   For queryType = ["insert", "addToValue", "get", "insert", "addToKey", "addToValue", "get"] and 
//            query = [[1, 2], [2], [1], [2, 3], [1], [-1], [3]], the output should be solution(queryType, query) = 6.

// The hashmap looks like this after each query:

//     1 query: { 1: 2 }
//     2 query: { 1: 4 }
//     3 query: answer is 4
//     4 query: { 1: 4, 2: 3 }
//     5 query: { 2: 4, 3: 3 }
//     6 query: { 2: 3, 3: 2 }
//     7 query: answer is 2
// The sum of the results for all the get queries is equal to 4 + 2 = 6.
//方法1:
  // function solution(queryType,query){
  //   let obj={}
  //   let count=0
  //   for (let i=0;i<queryType.length;i++){
  //     let type=queryType[i]
  //     let params=query[i]
  //     if(type==="insert"){
  //       let key=params[0]
  //       let value=params[1]
  //       obj[key]=value
  //     }else if(type==="addToValue"){
  //       for(let j in obj){
  //         obj[j]+=params[0]
  //       }
  //     }else if(type==="addToKey"){
  //       let newObj={}
  //       for(let j in obj){
  //         let newKey=parseInt(j)+params[0]
  //         let newValue=obj[j]+params[0]
  //         newObj[newKey]=newValue
  //       }
  //       obj=newObj
  //     }else if(type==="get"){
  //       count+=obj[params[0]]

  //     }
  //   }
  //     return count
    

  // }


  // const queryTypes = ["insert", "insert", "addToValue", "addToKey", "get"];
  // const queries = [[1, 2], [2, 3], [2], [1], [3]];
  // console.log(solution(queryTypes,queries))
  
//方法2
  // class MyHashMap {
  //   constructor() {
  //     this.map = {};
  //   }

  //   insert(key, value) {
  //     this.map[key] = value;
  //   }

  //   get(key) {
  //     return this.map[key] || 0;
  //   }

  //   addToKey(x) {
  //     const updatedMap = {};
  //     for (let key in this.map) {
  //       updatedMap[Number(key) + x] = this.map[key];
  //     }
  //     this.map = updatedMap;
  //   }

  //   addToValue(y) {
  //     for (let key in this.map) {
  //       this.map[key] += y;
  //     }
  //   }
  // }

  // function solution(queryType, queries) {
  //   const hashMap = new MyHashMap();
  //   let sum = 0;

  //   for (let i = 0; i < queryType.length; i++) {
  //     const type = queryType[i];
  //     const args = queries[i];

  //     if (type === "insert") {
  //       hashMap.insert(args[0], args[1]);
  //     } else if (type === "get") {
  //       sum += hashMap.get(args[0]);
  //     } else if (type === "addToKey") {
  //       hashMap.addToKey(args[0]);
  //     } else if (type === "addToValue") {
  //       hashMap.addToValue(args[0]);
  //     }
  //   }

  //   return sum;
  // }

// const queryType = ["insert", "insert", "addToValue", "addToKey", "get"];
// const queries = [[1, 2], [2, 3], [2], [1], [3]];

// console.log(solution(queryType, queries)); // Output: 5
//
//Tests passed: 19/30. Execution time limit exceeded on test 20:
// Program exceeded the execution time limit. Make sure that it completes execution in a few seconds for any possible input.
//说明有一些问题，需要解决

//练习26
//arr=["is","version","hello"]
//string="IsVersion"
//arr 中任意两个组合能得到string，return true
//注意string中的两个首字母都大写
//可以将arr中的每个item中的首字母大写

// function upperCase(str){
//    let upper=str[0].toUpperCase()
//    let rest=str.slice(1)
//    return upper+rest
// }


// function solution(arr,str){
//   let newArr=[]
//   for (let j of arr){
//     let item=upperCase(j)
//     newArr.push(item)
//   }
//   //i ['Is', 'Version', 'Hello']
//   //k ['Is', 'Version', 'Hello']
//   for (let i=0;i<newArr.length;i++){
//     for(let k=i+1;k<newArr.length;k++){
//       let letter=newArr[i]+newArr[k]
//       if(letter===str){
//         return true
//       }

//     }
//   }
//   return false
// }
//   console.log(solution(["is", "version", "hello"],"IsVersion"))

 // 14---与上题类似
 
//For words = ["is", "valid", "right"] and variableName = "isValid",
//the output should be solution(words, variableName) = true.
//words: ["a"]   variableName: "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"----true
//words:["ayrtu", "ceinm", "nbcyjsghf", "ukw", "in", "noiobkq","eqlpggfocl", "cri", "ikgtzxc", "oll"]
 // variableName: "InCeinm"---true
//其目的是检查给定的变量名 variableName 是否可以由列表 words 中的单词组成，而且这些单词必须以 CamelCase 形式连接
//str.split(/(?=[A-Z])/)客可以把字符串中的大写字母开头的单词分割出来
  // function solution(words, variableName) {
  //   const camelCase = (str) => {
  //     return str.split(/(?=[A-Z])/).map(word => word.toLowerCase());
  //   };

  //   const variableNameWords = camelCase(variableName);

  //   for (const word of variableNameWords) {
  //     if (!words.includes(word)) {
  //       return false;
  //     }
  //   }

  //   return true;
  // }

//练习27
//array中含有多少个不一样的string，eg:["ABBC"] A,B,C
//用A，B，C三个数凑成一个Palindrome回文

//用includes（）方法找出vowels，并大写
    // let word="Hello" 
    // function solution(a){
    //   const arr=a.split("")
    //   let arr2=arr.map(x=>x.toLowerCase())
    //   let vowels=["a","e","i","o","u"]
    //   let result=[]
    //   for (let i in arr2){
    //     if (vowels.includes(arr2[i])){
    //       result.push(arr2[i].toUpperCase())
    //     }else{
    //       result.push(arr2[i])
    //     }
        
        
    //   }
    // // console.log(result)
     
    // }
    // console.log(solution(word))

   
//练习28
//     You are given a set of closed line segments, represented as a two - dimensional integer array segments.
//Each segment segments[i] is of the form[l, r], where l is the coordinate of its left endpoint and 
//r is the coordinate of its right endpoint.

//  Let's say that the segment [l, r] contains the point x if the point is located inside the segment, i.e. l ≤ x ≤ r. 
//Your task is to find the minimal number of points that can be placed somewhere on the number line, 
//so that each segment contains at least one point.

//       Example

//       For

//       segments = [[-1, 3],
//       [-5, -3],
//       [3, 5],
//       [2, 4],
//       [-3, -2],
//       [-1, 4],
//       [5, 5]]
  // let segments = [[-1, 3], [-5, -3],[3, 5],[2, 4],[-3, -2],[-1, 4],[5, 5]]
  
  // function solution(segments) {
  
  //     segments.sort((a, b) => a[1] - b[1]);
  //     return segments
  // }
  // console.log(solution(segments))
// the output should be solution(segments) = 3.
//解释 output 一个array=[-3,3,5]，表示每一个segment中至少有一个坐标在array中，output 这个array的length=3
// You can place 3 points, at positions - 3, 3, and 5 to fit the requirement:

//       Segment[-1, 3] will contain point 3;
//       Segment[-5, -3] will contain point - 3;
//       Segment[3, 5] will contain points 3 and 5;
//       Segment[2, 4] will contain point 3;
//       Segment[-3, -2] will contain point - 3;
//       Segment[-1, 4] will contain point 3;
//       Segment[5, 5] will contain point 5.
//       example

// You cannot place 2 points or fewer to cover all segments,
// because segments[-5, -3], [2, 4], and[5, 5] have no points in common.So, the answer is 3.
//这道题主要的意思在生成一个arr,里面至少要放几个数字，使得input中的每个segment中都至少包含一个arr中的数字
  //方法：
// function solution(segments) {
  //     // 对线段按右端点坐标进行升序排序
  //     segments.sort((a, b) => a[1] - b[1]);

  //     let points = [];
  //     let currentPoint = segments[0][1];
  //     points.push(currentPoint);

  //     for (let i = 1; i < segments.length; i++) {
  //       const segment = segments[i];
  //       if (segment[0] > currentPoint) {
  //         // 如果当前线段的左端点大于当前点的位置，需要放置一个新点
  //         currentPoint = segment[1];
  //         points.push(currentPoint);
  //       }
  //     }

  //     return points.length;
  //   }

  //   // 示例用法
  //   const segments = [[-1, 3], [-5, -3], [3, 5], [2, 4], [-3, -2], [-1, 4], [5, 5]];
  //   const minPoints = solution(segments);
  //   console.log(minPoints); // 输出 3
  //   这个函数首先对线段按照右端点坐标进行升序排序，然后使用一个变量 currentPoint 来追踪当前放置的点的位置。然后，它遍历每个线段，如果当前线段的左端点大于当前点的位置，就需要放置一个新点，并更新 currentPoint。最后，返回放置的点的数量，即最少需要多少个点来满足所有线段的要求。


//练习 31
//s="sample this is this sample"      return----"sample this is"
//得到不重复的内容

// function solution(s){
//   let arr=s.split(" ")
//   let obj={}
//   for (let i of arr){
//     if(i in obj){
//       obj[i]++
//     }else{
//       obj[i]=1
//     }
//   }
//   return Object.keys(obj).join(" ")

// }

// console.log(solution(string))

  //练习31 caching缓存
  // function f(n){
  //   let r=1
  //   for(let i=0;i<5000000;i++){
  //     r=((r+n)*n)%9973
  //   }
  //   return r
  // }
  // //num=[1,2,2,2,1,4]
  // function solution(num){
  //   let store={}
  //   let output=[]
  //   for (let j of num){
  //     if (j in store){
  //       output.push(store[j])
  //     }else{
  //       let value=f(j)
  //       store[j]=value
  //       output.push(value)
  //     }
  //   }
  //   return output

  // }
  //练习32
  // fibonacci number 斐波纳契数
  //item: 0,1,2,3,4,5,6, 7,8 ,9 ,10 ,11
  //value:0,1,1,2,3,5,8,13,21,34,55, 89
  // function fib(n){
  //   if(n===0){
  //     return 0
  //   }else if(n===1){
  //     return 1
  //   }else{
  //     return f(n-1)+f(n-2)f
  //   }
  // }
  // console.log(fib(6))
  //加入cache帮助减少上述fib()function 的内部递归运算
  // function fib(n,cache={}){
  //   if (n===0)return 0;
  //   if(n===1)return 1;
  //   if (n in cache)return cache[n]
  //   const output=fib(n-1,cache)+fib(n-2,cache)
  //   cache[n]=output
  //   return output
  // }
  // function solution(n){
  //   return fib(n)
  // }
  
//  一个array[]的length为偶数，将里面的items平均分成两个array，并且每个inner array中所包含的item都不相同，
//如果相同，则return [],output为随意正确的组合
//例如 [1,2,2,3,4,3]---->return [[1,2,3],[2,3,4]] 
// function splitArray(arr) {
//   // 创建两个空数组用于存放结果
//   const result1 = [];
//   const result2 = [];

//   // 遍历原始数组
//   for (const item of arr) {
//     // 如果结果数组1中不包含该元素，将其添加到结果数组1
//     if (!result1.includes(item)) {
//       result1.push(item);
//     }
//     // 否则，将其添加到结果数组2
//     else {
//       result2.push(item);
//     }
//   }

//   // 如果结果数组1的长度等于结果数组2的长度，返回两个结果数组，否则返回空数组
//   return result1.length === result2.length ? [result1, result2] : [];
// }

//   const inputArray = [1, 2, 2, 3, 4, 3];
//   const output = splitArray(inputArray);

//   console.log(output); // 输出 [[1, 2, 3], [2, 3, 4]]




      //If there are no possible answers, return an empty array.  ----->return []

    //}
    //练习34:计算grid1中有几个‘WLW'水平方向、垂直方向，左斜方向，右斜方向
    // const grid1 = [
    //     ['W', 'L', 'W', 'W', 'W'],
    //     ['W', 'L', 'W', 'W', 'W'],
    //     ['W', 'W', 'W', 'L', 'W'],
    //     ['W', 'W', 'L', 'L', 'W'],
    //     ['L', 'W', 'W', 'L', 'L'],
    //     ['L', 'L', 'W', 'W', 'W']
    //   ];
  // function countWLWCombinations(grid) {
  //     function countHorizontalWLW(grid) {
  //       let count = 0;
  //       for (let i = 0; i < grid.length; i++) {
  //         for (let j = 0; j < grid[i].length - 2; j++) {
  //           if (grid[i][j] === 'W' && grid[i][j + 1] === 'L' && grid[i][j + 2] === 'W') {
  //             count++;
  //           }
  //         }
  //       }
  //       return count;
  //     }

  //     function countVerticalWLW(grid) {
  //       let count = 0;
  //       for (let i = 0; i < grid.length - 2; i++) {
  //         for (let j = 0; j < grid[i].length; j++) {
  //           if (grid[i][j] === 'W' && grid[i + 1][j] === 'L' && grid[i + 2][j] === 'W') {
  //             count++;
  //           }
  //         }
  //       }
  //       return count;
  //     }

  //     function countDiagonalLeftWLW(grid) {
  //       let count = 0;
  //       for (let i = 0; i < grid.length - 2; i++) {
  //         for (let j = 0; j < grid[i].length - 2; j++) {
  //           if (grid[i][j] === 'W' && grid[i + 1][j + 1] === 'L' && grid[i + 2][j + 2] === 'W') {
  //             count++;
  //           }
  //         }
  //       }
  //       return count;
  //     }

  //     function countDiagonalRightWLW(grid) {
  //       let count = 0;
  //       for (let i = 0; i < grid.length - 2; i++) {
  //         for (let j = 2; j < grid[i].length; j++) {
  //           if (grid[i][j] === 'W' && grid[i + 1][j - 1] === 'L' && grid[i + 2][j - 2] === 'W') {
  //             count++;
  //           }
  //         }
  //       }
  //       return count;
  //     }

  //     let horizontalCount = countHorizontalWLW(grid);
  //     let verticalCount = countVerticalWLW(grid);
  //     let diagonalLeftCount = countDiagonalLeftWLW(grid);
  //     let diagonalRightCount = countDiagonalRightWLW(grid);

  //     return horizontalCount + verticalCount + diagonalLeftCount + diagonalRightCount;
  //   }

  //   const grid1 = [
  //     ['W', 'L', 'W', 'W', 'W'],
  //     ['W', 'L', 'W', 'W', 'W'],
  //     ['W', 'W', 'W', 'L', 'W'],
  //     ['W', 'W', 'L', 'L', 'W'],
  //     ['L', 'W', 'W', 'L', 'L'],
  //     ['L', 'L', 'W', 'W', 'W']
  //   ];
  //   const grid2 = [
  //       ['W', 'L', 'W', 'W', 'W'],
  //       ['W', 'L', 'W', 'W', 'W'],
  //       ['W', 'W', 'W', 'L', 'W'],
       
  //     ];

  //   const combinations = countWLWCombinations(grid2);
  //   console.log(combinations);

//35题
// You are given an array of integers memory consisting of 0s and 1s - 
  //whether the corresponding memory unit is free or not.memory[i] = 0 means that the ith memory unit is free,
  // and memory[i] = 1 means it's occupied.

  // Your task is to perform two types of queries:
  //   memory[i] = 0空位      memory[i] = 1被占领
  // alloc X: Find the left - most memory block of X consecutive free memory units and mark these units as occupied 
  //(ie: find the left-most contiguous subarray of 0s, and replace them all with 1s).
  // If there are no blocks with X consecutive free units, return -1; 
  //otherwise return the index of the first position of the allocated block segment and assign an ID to every single element in this block,
  // based on an atomic counter(the counter starts at 1 and is incremented on every successful alloc operation).
//alloc(2)从左到右找到两个连续的0，并全变成1

// erase ID: If there exists an allocated memory block with element ids equal to ID, free all its memory units.
// Return the length of the deleted memory block.If there is no such ID or the block with this ID has already been deleted, return -1.
// The queries are given in the following format:

// queries is an array of 2 - elements arrays;
//   if queries[i][0] = 0 then this is an alloc type query, where X = queries[i][1];
//   if queries[i][0] = 1 then this is an erase type query, where ID = queries[i][1].
// Return an array containing the results of all the queries.

//     Note: You are not expected to provide the most optimal solution, 
//but a solution with time complexity not worse than O(memory.length2 · queries.length) will fit within the execution time limit.

//Example

// For memory = [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0] and 
//queries = [[0, 2], [0, 1], [0, 1], [1, 2], [1, 4], [0, 4]],
// the output should be solution(memory, queries) = [2, 0, 4, 1, -1, -1].

// Expand to see the example video.

//     Note: If you are not able to see the video, use this link to access it.

// [0, 2] corresponds to alloc 2, which allocates a memory block from units 2 to 3. 
//We also assign ID = 1 to this segment.After this operation memory = [0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0].
//Return the memory block starting index - 2.

//   [0, 1] corresponds to alloc 1, which allocates a memory block from units 0 to 0. 
//After this operation, memory = [1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0].We also assign ID = 2 to this segment.

// [0, 1] corresponds to alloc 1, which allocates a memory block from units 4 to 4. After this operation,
// memory = [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0].We also assign ID = 3 to this segment.

// [1, 2] corresponds to erase 2. The range with ID = 2 is[0, 0](just the 0th element).After freeing the memory, 
//memory = [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0].Return the length of the removed memory block - 1.

//   [1, 4] corresponds to erase 4. The current counter is equal to 3(since there have been 3 successful allocations), 
//so we return -1 since there is no range with ID = 4.
//   [0, 4] corresponds to alloc 4. There is no memory block of length 4 in which all blocks are free, so return -1.
// function alloc(arr,number){
//   let item=''
//   let changed=''
//   for(let m=0;m<number;m++){
//     item+=0
//     changed+=1

//   }
//   let str= arr.join('')
//   if(str.includes(item)){
    
//     let res=str.replace(item,changed)
    
//   }
  
 
//   return res

// }

// let arr=[0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]
// let num=2
// console.log(alloc(arr,num))
// function solution(memory,queries){
//   for(let i=0;i<queries.length;i++){
//     let query=queries[i][0]
//     let num=queries[i][1]
//     if(query===0){

//     }
//   }

// }
  // function solution(memory, queries) {
  //     const results = [];
  //     let counter = 1; // 用于分配ID

  //     for (const query of queries) {
  //       if (query[0] === 0) {
  //         const size = query[1];
  //         let startIndex = -1;

  //         // 找到连续的X个空位
  //         for (let i = 0; i < memory.length; i++) {
  //           if (memory[i] === 0) {
  //             if (startIndex === -1) {
  //               startIndex = i;
  //             }
  //             if (i - startIndex + 1 === size) {
  //               break;
  //             }
  //           } else {
  //             startIndex = -1;
  //           }
  //         }

  //         if (startIndex !== -1) {
  //           // 分配内存单元
  //           for (let i = startIndex; i < startIndex + size; i++) {
  //             memory[i] = 1;
  //           }
  //           results.push(startIndex + 1); // 返回分配的内存块的起始位置
  //           counter++; // 增加ID计数器
  //         } else {
  //           results.push(-1); // 无法找到足够的连续空位
  //         }
  //       } else if (query[0] === 1) {
  //         const id = query[1];
  //         let blockSize = 0;

  //         // 查找并释放具有指定ID的内存块
  //         for (let i = 0; i < memory.length; i++) {
  //           if (memory[i] === id) {
  //             memory[i] = 0;
  //             blockSize++;
  //           }
  //         }

  //         if (blockSize > 0) {
  //           results.push(blockSize);
  //         } else {
  //           results.push(-1); // 未找到具有指定ID的内存块
  //         }
  //       }
  //     }

  //     return results;
  //   }

  //   const memory = [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0];
  //   const queries = [[0, 2], [0, 1], [0, 1], [1, 2], [1, 4], [0, 4]];
  //   const result = solution(memory, queries);
  //   console.log(result); // 输出 [2, 0, 4, 1, -1, -1]

  


//36题
//let a=[2,3,1,4,6,8] k=3,将a中的items两两相加，得到的数是否能被k整除，如果能，有多少对（注意：考试中有一个hide test未通过，
//错误提示是超时了，验证每次验证过的item就从b中删除,这样可以保证每次loop的数量越来越少
//a = [2, 3, 1, 4, 6, 8]
//b = [2, 3, 1, 4, 6, 8]


//37题
// Given matrix, an n x n square matrix of integers, let's define its 0-border as the union of its leftmost and rightmost columns, as well as its top and bottom rows.

// If we were to remove the matrix's 0-border, then the 0-border of the resulting matrix can be defined as the 1-border of the original matrix. We can continue this way to define the 2-border, 3-border, etc.

//   0 - border	1 - border	2 - border
		
// For each k in [0, 1, ..., floor((n - 1) / 2)], your task is to sort the elements in each k - border and place them in clockwise order, starting from the top - left corner.

//     Note: You are not expected to provide the most optimal solution, but a solution with time complexity not worse than O(n3) will fit within the execution time limit.

//       Example

//   For

//   matrix = [[9, 7, 4, 5],
//   [1, 6, 2, -6],
//   [12, 20, 2, 0],
//   [-5, -6, 7, -2]]
// the output should be

//   solution(matrix) = [[-6, -6, -5, -2],
//   [12, 2, 2, 0],
//   [9, 20, 6, 1],
//   [7, 7, 5, 4]]
// The 0 - border consists of the elements[9, 7, 4, 5, -6, 0, -2, 7, -6, -5, 12, 1].After sorting, the elements order is[-6, -6, -5, -2, 0, 1, 4, 5, 7, 7, 9, 12].So we'll place these back on the matrix clockwise, starting from the top-left corner.
// The 1 - border consists of the elements[6, 2, 2, 20].After sorting, the elements order is[2, 2, 6, 20].

//回文题，如果没有回文就返回最小的一个字母
//如果组成了很多回文，选择最小的一个回文，并输出
// You're developing a new programming language with some unusual features for strings! Among these is a method that returns the longest palindrome that can be formed with the characters of a given string.

// Given a string s, your task is to find this longest possible palindrome.You may use any number of the characters from s, and arrange them in any order(so long as it results in a palindrome).

// If there are multiple longest palindromes that can be formed, return the one among them that's lexicographically smallest.

//   Example

// For s = "aaabb", the output should be solution(s) = "ababa".

// There are two possible palindromes of length 5 that can be obtained("ababa" and "baaab"), but "ababa" is lexicographically smaller, thus it is the answer.

// For s = "aaabbbcc", the output should be solution(s) = "abcacba".

//     It's not possible to form a palindrome of length 8, but from several palindromes of length 7, "abcacba" is the lexicographically smallest, thus it is the answer.
//   

  //得到1，3，6，10等对应的value值，并连接起来成句子
  // 1
  // 2 3
  // 4 5 6
  // 7 8 9，10

  // let obj = { 3: 'love', 6: 'computers', 2: 'dogs', 4: 'cats', 1: 'I', 5: 'you' }

  // function change(arr) {
  //   //arr=['1', '2', '3', '4', '5', '6']

  //   let result = []

  //   let step = 1
  //   while (arr.length > 0) {
  //     let items = arr.slice(0, step)
  //     result.push(items)
  //     arr = arr.slice(step)
  //     step++

  //   }
  //   let lastItem = result.map(x => {
  //     let endItem = x.pop()
  //     return endItem
  //   })

  //   return lastItem

  // }

  // function solution(objects) {
  //   let keys = Object.keys(obj)
  //   //keys=['1', '2', '3', '4', '5', '6']
  //   let subArr = change(keys)
  //   // subArr=['1','3','5']
  //   let outputs = []
  //   // obj = { 3:'love',6:'computers',2:'dogs',4:'cats',1:'I',5:'you'}
  //   for (let j in subArr) {
  //     let item = subArr[j]
  //     outputs.push(objects[item])

  //   }
  //   let final = outputs.join(' ')


  //   return final
  // }
  // console.log(solution(obj))

//左右不分的号令,叫'left,总有人转'Right'，叫'right'总有人转“left"
  // function solution(commands) {
  //   let count = 0
  //   let same = true

  //   for (let i = 0; i < commands.length; i++) {
  //     let command = commands[i]
  //     if (command === 'L' || command === 'R') {
  //       same = !same
  //     }
  //     if (same) count++


  //   }
  //   return count
  // }

//例如；commands: "AALAAALARAR"----5；"RRRRRRRRRRLLLLLLLLLRRRRLLLLLLLLLL"---16；"LLARL"----3

//recursion 来解决循环问题：
//For n = 15, the output should be solution(n) = 20;
//For n = 1234, the output should be solution(n) = 1000.    1234 -> 1230 -> 1200 -> 1000.
//For n = 1445, the output should be solution(n) = 2000.    1445 -> 1450 -> 1500 -> 2000.
 

  //方法1:
// function solution(n) {
  //   if (n < 10) {
  //     return n;
  //     // 递归结束条件，当 n 小于 10 时，直接返回 n
  //   }

  //   let lastDigit = n % 10;
  //   let x = Math.floor(n / 10);

  //   if (lastDigit < 5) {
  //     return solution(x) * 10;
  //     // 递归调用并将结果乘以 10
  //   } else {
  //     return solution(x + 1) * 10;
  //     // 递归调用并将结果加 1 再乘以 10
  //   }
  // }
//方法2:
  //Math.round(value / 10)四舍五入取整数
  // function solution(value) {
  //   var r = 0
  //   while (value > 10) {
  //     value = Math.round(value / 10)
  
  //     r++
  //   }
  //   return value * Math.pow(10, r)
  // }

  //greatest common divisor 最大公约数
  // function GCD(maxItem,minItem){
  //   let remainder=maxItem%minItem
  //   if(remainder===0){
  //     return minItem
  //   }else{
  //     return GCD(minItem,remainder)
  //   }
  // }
  // console.log(GCD(3768,1701))
//
  //Determine if the given number is a power of some non-negative integer.
//就是给出一个结果，求是不是能存在一个数，经过多少次的幂，可以得到，125=5*5*5， Math.pow(5,3)
//相当于对底数先一个一个试（外循环），然后再对指数慢慢试（内循环）
//1的多少次幂都是本身
//function solution(n) {
//   if (n === 1) {
//     return true
//   }
//   for (let i = 2; i * i <= n; i++) {
//     for (let j = 2; Math.pow(i, j) <= n; j++) {
//       if (Math.pow(i, j) === n) {
//         return true
//       }
//     }
//   }
//   return false
    

// }
// Find the number of ways to express n as sum of some(at least two) consecutive positive integers.
//给一个结果，看有几种方式可以使得连续的书，相加
//     Example
// For n = 9, the output should be  solution(n) = 2.
// There are two ways to represent n = 9: 2 + 3 + 4 = 9 and 4 + 5 = 9.
// For n = 8, the output should be solution(n) = 0.
// There are no ways to represent n = 8.
  // function solution(n) {
  //   let count = 0
  //   for (let i = 1; i < n; i++) {
  //     let s = i
  //     for (let j = i + 1; j < n; j++) {
  //       s += j
  //       if (s === n) {
  //         count++
  //       }
  //       if (s > n) {
  //         break
  //       }
  //     }
  //   }
  //   return count

  // }
  //处理isomorphic同构问题，
    //  let isIsomorphic = function (s, t) {
    //     if (s.length !== t.length) {
    //       return false
    //     }
    //     for (let i = 0; i < s.length; i++) {
    //       if (s.indexOf(s[i]) !== t.indexOf(t[i])) {
    //         return false
    //       }

    //     }
    //     return true
    //   };
    //'foo','bar'=>false  'paper','title'=>true
  //处理recurion 的问题，new Set()，
  // Example 1:

  //   Input: n = 19
  //   Output: true
  //   Explanation:
  //   12 + 92 = 82
  //   82 + 22 = 68
  //   62 + 82 = 100
  //   12 + 02 + 02 = 1
  //直到=1截止
  // Example 2:

  //   Input: n = 2
  //   Output: false

  //方法1
  // var isHappy = function (n, seen = new Set()) {
  //   let arr = n.toString().split('').map(x => parseInt(x) * parseInt(x))
  //   let num = arr.reduce((res, index) => res + index, 0)
  //   if (num === 1) {
  //     return true
  //   }
  //   if (seen.has(num)) {
  //     return false
  //   }
  //   seen.add(num)
  //   return isHappy(num, seen)

  // };
  //方法2
  // var isHappy = function (n) {
  //     const checked = [];
  //     while (n !== 1) {
  //       if (checked.includes(n)) return false;
  //       checked.push(n);
  //       n = n.toString().split('').map(i => i ** 2).reduce((sum, i) => sum + i, 0);
  //     }
  //     return true;
  //   };


//leetcode:121:Best Time to Buy and Sell Stock
// You are given an array prices where prices[i] is the price of a given stock on the ith day.
// You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
// Return the maximum profit you can achieve from this transaction.If you cannot achieve any profit, return 0.
// Example 1:

//   Input: prices = [7, 1, 5, 3, 6, 4]
//   Output: 5
//   Explanation: Buy on day 2(price = 1) and sell on day 5(price = 6), profit = 6 - 1 = 5.
// Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
 //var maxProfit = function(prices) {
//     // [7,1,5,3,6,4]
//     let profit=0
//     let min=prices[0]
//     for(let i=1;i<prices.length;i++){
//         if(prices[i]<min){
//             min=prices[i]
//         }else{
//             profit=Math.max(profit,prices[i]-min)
//         }

//     }
//     return profit
   
    
// };

//80. Remove Duplicates from Sorted Array II
// Given an integer array nums sorted in non - decreasing order, remove some duplicates in -place such that each unique element appears at most twice.The relative order of the elements should be kept the same.
// Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums.More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.It does not matter what you leave beyond the first k elements.
// Return k after placing the final result in the first k slots of nums.
//Do not allocate extra space for another array.You must do this by modifying the input array in -place with O(1) extra memory.
//   Input: nums = [1, 1, 1, 2, 2, 3]
//   Output: 5, nums = [1, 1, 2, 2, 3, _]
//   Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
// It does not matter what you leave beyond the returned k(hence they are underscores).

//就是保留只出现少于等于2次的元素
  // var removeDuplicates = function (nums) {

  //   let count = 1
  //   let k = 1
  //   for (let i = 1; i < nums.length; i++) {
  //     if (nums[i] === nums[i - 1]) {
  //       count++

  //     } else {
  //       count = 1
  //     }
  //     if (count <= 2) {
  //       nums[k] = nums[i]
  //       k++
  //     }

  //   }
  //   return k
  // };

//55.Jump Game
//You are given an integer array nums.You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.
//Return true if you can reach the last index, or false otherwise.

    //Example 1:
  //Input: nums = [2, 3, 1, 1, 4]
  //Output: true
  //Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
  //  Example 2:

  //Input: nums = [3, 2, 1, 0, 4]
 // Output: false
  //Explanation: You will always arrive at index 3 no matter what.Its maximum jump length is 0, which makes it impossible to reach the last index.

  // var canJump = function (nums) {
  //   // Base condition...
  //   if (nums.length <= 1)
  //     return true;
  //   // To keep the maximum index that can be reached...
  //   let maximum = nums[0];
  //   // Traverse all the elements through loop...
  //   for (let i = 0; i < nums.length; i++) {
  //     //if there is no way to jump to next...
  //     // so we should return false...
  //     if (maximum <= i && nums[i] == 0)
  //       return false;
  //     //update the maximum jump...    
  //     if (i + nums[i] > maximum) {
  //       maximum = i + nums[i];
  //     }
  //     //maximum is enough to reach the end...
  //     if (maximum >= nums.length - 1)
  //       return true;
  //   }
  //   return false;
  // };
  //----------------------------------- TikTok-------------------------------------------------
  //1.what is the output when the recommendation system calls dijkstra(graph,0)
  //to find the least similar  products to the current product(Product 0)?
//存在4个选项：
  // A: [0，2，5，1，6]
  // B: [0, 1, 4, 2, 7]
  // C: [0, 2, 3, 1, 5]
  // D: [0, 2, 3, 1, 6]
  // let graph=[
  //   [0,2,0,1,0],
  //   [2,0,3,0,0],
  //   [0,3,0,4,0],
  //   [1,0,4,0,0],
  //   [0,0,0,5,0]
  // ]
  // function Dijkstra(graph, startProduct){
  //   let n=graph.length
  //   let minDistances=new Array(n).fill(Infinity)
  //   let visited=new Array(n).fill(false)
  //   minDistances[startProduct]=0
  //   for(let i=0;i<n;i++){
  //     let minIndex=-1
  //     for(let j=0;j<n;j++){
  //       if(!visited[j]&&(minIndex===-1||minDistances[j]<minDistances[minIndex])){
  //         minIndex=j
  //       }
  //     }
  //     if(minDistances[minIndex]===Infinity){
  //       break
  //     }
  //     visited[minIndex]=true
  //     for(let j=0;j<n;j++){
  //       if(graph[minIndex][j]!==0){
  //         let potentialDist=minDistances[minIndex]+graph[minIndex][j]
  //         if(potentialDist<minDistances[j]){
  //           minDistances[j]=potentialDist
  //         }
  //       }
  //     }
  //   }
  //   return minDistances

  // }
  //2.what will be the output when these operations are performed on a Doubly Ended Queue?
//Insertfront(1)
//Insertfront(2)
//Insertrear(3)
//Insertrear(4)
//Deletefront()
//Insertfront(5)
//Deleterear()
//Display()

//3.Profit Targets
//A financial analyst is respinsible for a portfolio of profitable stocks represented in an array.
//Each item in the array represents the yearly profit of a corresponding stock.
//The analyst gathers all distinct pairs of stocks that reached the target profit. Distinct pairsare pairs
//that differ in at least one element.Given the array of profits, find the number of distinct pairs of
//stocks where the sum of each pair's profits is exactly equal to the target profit.
 //  example： stocksProfit=[5，7，9，13，11，6，6，3，3]
 // target=12
 //There are 4 pairs of stocks that have the sum of their profits equals to the target 12.Note that because there are
 // two instances of 3 in stocksProfit there are two pairs matching(9,3):stockProfits indices 2 and 7,and indices 2 and 8,
 //but only one can be included.
 //There are 3 distinct pairs of stocks:(5,7),(3,9),and (6,6) and the return value is 3
//
  // function stockPairs(stocksProfit, target) {


  //   let seen = new Set();
  //   let pairs = new Set();

  //   for (let profit of stocksProfit) {
  //     let complement = target - profit;
  //     if (seen.has(complement)) {
  //       let pair = [Math.min(profit, complement), Math.max(profit, complement)];
  //       pairs.add(pair.toString());
  //     }
  //     seen.add(profit);
  //   }

  //   return pairs.size;


  // }

//new Set() 是 JavaScript 中用来创建一个 Set 对象的语法。

// Set 是一种特殊的数据结构，它类似于数组，但与数组不同的是，Set 中的每个值都是唯一的，也就是说，它不会包含任何重复的值。

//     主要特点：
//     唯一性：Set 中的值是唯一的，不能重复。
//     大小：Set 的大小可以通过 size 属性来获取。
//     自动去重：当你将多个相同的值添加到 Set 中时，Set 只会保留一个。
//     遍历：可以使用 for...of 循环或 forEach 方法来遍历 Set 中的元素。
//     常用方法：
//     add(value)：向 Set 中添加一个新元素。如果该元素已经存在，则不会添加。
//     delete (value)：从 Set 中删除指定的元素。
//     has(value)：检查 Set 中是否存在指定的元素，返回 true 或 false。
//     clear()：清空 Set 中的所有元素。
//     size：获取 Set 中元素的数量。

//56.Powers of Two(意思就是说能被2整除)
// while(num%2===0){
//   num=num/2
// }
// if(num===1){
//   return true
// }else{
//   return fasle
// }
//这个思维就是只要能被2整除，我就继续，当不能被整除的时候，说明num！==1；只要是能被整除，最后都会是2/2===1

//57.str=‘cats AND*Dogs-are Awesome'时，返回'cats_and_dogs_are_awesome'
//意思就是说将一切非letter都换成‘_',letter都小写
  // let newStr = str.split(/(\W+)/).map(x => {
  //   if (/[^a-zA-Z]/.test(x)) {
  //     return '_';
  //   } else {
  //     return x.toLowerCase();
  //   }
  // });
// ------------------------  /\d/.test(x) ----->表示是不是数字
// ------------------------  /(\W+/) ----->非字母

//tiktok:hash password,给定一个密码，这个密码后面加一个character，也可以通过
  // function setPassword(str) {
  //     let arr = str.split('').map(x => parseInt(x.charCodeAt(0)));
  //     let sum = 0;
  //     let Mod = (10 ** 9) + 7;

  //     for (let i = 0; i < arr.length; i++) {
  //       sum += arr[i] * (131 ** (arr.length - i - 1));
  //     }

  //     let res = sum % Mod;
  //     console.log(`String: ${str}, Hash: ${res}`); // 输出字符串及其对应的哈希值
  //     return res;
  //   }

  //   function authEvents(events) {
  //     let word = []; // 存储哈希值
  //     let check = []; // 存储验证结果

  //     for (let i = 0; i < events.length; i++) {
  //       if (events[i][0] === 'setPassword') {
  //         let letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  //         let combined = letters.map(x => events[i][1] + x);

  //         // 对原始字符串生成哈希值
  //         let hashOriginal = setPassword(events[i][1]);
  //         word.push(hashOriginal);

  //         // 对原始字符串+字母的组合生成哈希值
  //         for (let j = 0; j < combined.length; j++) {
  //           let hashCombined = setPassword(combined[j]);
  //           word.push(hashCombined);
  //         }
  //       } else if (events[i][0] === 'authorize') {
  //         let authValue = parseInt(events[i][1]);
  //         if (word.includes(authValue)) {
  //           check.push(1);
  //         } else {
  //           check.push(0);
  //         }
  //       }
  //     }

  //     console.log("Stored hash values: ", word); // 打印所有存储的哈希值
  //     return check;
  //   }

  //   // 测试
  //   let events = [
  //     ['setPassword', 'a'],
  //     ['authorize', '97'],
  //     ['authorize', '12756'],
  //     ['authorize', '12804'],
  //     ['authorize', '12829'],
  //     ['authorize', '12772'],
  //     ['authorize', '12797'],
  //     ['authorize', '98']
  //   ];

  //   console.log(authEvents(events));


  //20. Valid Parentheses
//   Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

// An input string is valid if:

// Open brackets must be closed by the same type of brackets.
// Open brackets must be closed in the correct order.
// Every close bracket has a corresponding open bracket of the same type.

// func isValid(s string) bool {
//     // 空字符串直接返回 true
//     if len(s) == 0 {
//       return true
//     }
//     stack:= make([]rune, 0)
//     for _, v := range s {
//       if (v == '[') || (v == '(') || (v == '{') {
//         stack = append(stack, v)
//       } else if ((v == ']') && len(stack) > 0 && stack[len(stack) - 1] == '[') ||
//         ((v == ')') && len(stack) > 0 && stack[len(stack) - 1] == '(') ||
//         ((v == '}') && len(stack) > 0 && stack[len(stack) - 1] == '{') {
//         stack = stack[: len(stack) - 1]
//       } else {
//         return false
//       }
//     }
//     return len(stack) == 0
//   }

//   42. Trapping Rain Water
//   Given n non - negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
//   func trap(height[]int) int {
//       res, left, right, maxLeft, maxRight := 0, 0, len(height) - 1, 0, 0
//       for left <= right {
//         if height[left] <= height[right] {
//           if height[left] > maxLeft {
//         maxLeft = height[left]
//       } else {
//         res += maxLeft - height[left]
//       }
//       left++
//     } else {
//       if height[right] >= maxRight {
//         maxRight = height[right]
//       } else {
//         res += maxRight - height[right]
//       }
//       right--
//     }
// 	}
//     return res
// }

//   71. Simplify Path
//   You are given an absolute path for a Unix - style file system, which always begins with a slash '/'.Your task is to transform this absolute path into its simplified canonical path.
// The rules of a Unix - style file system are as follows:
// A single period '.' represents the current directory.
// A double period '..' represents the previous / parent directory.
// Multiple consecutive slashes such as '//' and '///' are treated as a single slash '/'.
// Any sequence of periods that does not match the rules above should be treated as a valid directory or file name.For example, '...' and '....' are valid directory or file names.
// The simplified canonical path should follow these rules:
// The path must start with a single slash '/'.
// Directories within the path must be separated by exactly one slash '/'.
// The path must not end with a slash '/', unless it is the root directory.
// The path must not have any single or double periods('.' and '..') used to denote current or parent directories.
// Return the simplified canonical path.
// func simplifyPath(path string) string {
//     arr:= strings.Split(path, "/")
//     stack:= make([]string, 0)
//     var res string
//     for i := 0; i < len(arr); i++ {
//       cur:= arr[i]
//       //cur := strings.TrimSpace(arr[i]) 更加严谨的做法应该还要去掉末尾的空格
//       if cur == ".." {
//         if len(stack) > 0 {
//           stack = stack[: len(stack) - 1]
//         }
//       } else if cur != "." && len(cur) > 0 {
//         stack = append(stack, arr[i])
//       }
//     }
//     if len(stack) == 0 {
//       return "/"
//     }
//     res = strings.Join(stack, "/")
//     return "/" + res
//   }
  


  
  </script>
</body>

</html>
    
 
    

    





