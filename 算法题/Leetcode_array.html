<!DOCTYPE html>
<html lang="en">

<head>
  <title>Web App</title>
  <style>
    
   
      
    
  </style>
</head>

<body>
  
  
  <script>

    //函数1: 初始化结果矩阵 O（m*n）
    //  const res = Array.from({ length: rows }, () => Array(cols).fill(0));
   
// ----------------------------------0001:Two Sum----------------------------------
// 意思就是说要从一个array中找到"唯一"一对数字（a,b),a+b=target
// 返回的是(a,b)相对应的index
// Input: nums = [3,2,4], target = 6 // 3:0,4:1,2:2
// Output: [1, 2]

//   最优的做法时间复杂度是 O(n)
    // function twoSum(nums, target) {
    //     const map = {};

    //     for (let i = 0; i < nums.length; i++) {
    //         const another = target - nums[i];
    //         if (another in map) {
    //             return [map[another], i];
    //         }
    //         map[nums[i]] = i;
    //     }

    //     return null;
    // }

  // ----------------------------------000167. Two Sum II - Input Array Is Sorted----------------------------------
//一个升序的array，找到其中两个num1+num2=target.return 两个index+1
//Input: numbers = [2, 7, 11, 15], target = 9
//Output: [1, 2]
//Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
//方法1:按照0001:Two Sum的思路，只需要将储存的index+1


//方法2:双指针（左右两边向中间靠拢）方法非常高效，特别适用于已排序的数组中寻找满足条件的两个元素的问题。
  // function twoSum167(numbers, target) {
  //    let i = 0, j = numbers.length - 1;
  //   while (i < j) {
  //     if (numbers[i] + numbers[j] === target) {
  //       return [i + 1, j + 1]; // 返回的是 1 基索引
  //     }
  //     if (numbers[i] + numbers[j] < target) {
  //       i++;
  //     } else {
  //       j--;
  //     }
  //   }
  //   return null;
  // }



  // ----------------------------------00026:Remove Duplicates from Sorted Array----------------------------------
  // 题目条件：array不是一个降序的array
  //给定一个有序数组 nums(从小到大排列，所以重复项肯定是在旁边），对数组中的元素进行去重，使得原数组中的每个元素只有一个。最后返回去重以后数组的长度值。
  // 难点：就是return的还是原来的array，return原来array中唯一的item的length
  //[0,0,1,1,1,2,2,3,3,4]
  //[0,1,2,3,4]-->return 5  
//分析：
  
  //           i
  //[0,0,1,1,1,2,2,3,3,4]
  //                   c
  // function removeDuplicates(nums) {
  //     if (nums.length === 0) {
  //       return 0;
  //     }

  //     let insertIndex = 1
  //     for(let current =0; current <nums.length-1; current++){
  //       if(nums[current]!==nums[current+1]){
  //         nums[insertIndex] = nums[current + 1]
  //         insertIndex++
  //       }
  //     }
  //     return insertIndex

      
  //   }
   // ----------------------------------00027:Remove Element----------------------------------
   //这一题和26号相似，不同的是删除的是指定的number
  //     function removeElement(nums, val){

  //   let index=0
  //   for(let i=0;i<nums.length;i++){
  //     if(nums[i]!==val){
  //       nums[index]=nums[i]
  //       index++
  //     }

  //   }

  //  }
 // ----------------------------------00035:Search Insert Position---------------------------------- 
//这一题是经典的二分搜索的变种题，在有序数组中找到最后一个比 target 小的元素。write an algorithm with O(log n) runtime complexity.
  // function searchInsert(nums, target){
  //   let low = 0, high = nums.length - 1;

  //   while (low <= high) {
  //     let mid = low + ((high - low) >> 1);

  //     if (nums[mid] >= target) {
  //       high = mid - 1;
  //     } else {
  //       if (mid === nums.length - 1 || nums[mid + 1] >= target) {
  //         return mid + 1;
  //       }
  //       low = mid + 1;
  //     }
  //   }

  //   return 0;

  // }

  // function searchInsert(nums, target) {
  //     let low = 0, high = nums.length - 1;

  //     while (low <= high) {
  //       let mid = low + Math.floor((high - low) / 2);

  //       if (nums[mid] === target) { 
  //         return mid
  //       }
  //       if (nums[mid] > target) { //target 在左区间，所以[left, middle - 1]
  //         high = mid - 1
  //       } else {
  //         low = mid + 1  //target 在右区间，所以[middle + 1, right]
  //       }
  //     }

  //     return low;

  //   }

  // ----------------------------------00053:Maximum Subarray---------------------------------- 
//Given an integer array nums, find the subarray with the largest sum, and return its sum.
// A subarray is a contiguous part of an array
//分析：因为最后需要return的是maximum sum，所以不用管是那几个连续的数字，只需要用一个
// max 变量进行比较记录.逻辑思维：比较自身和自身与前面的数字相加进行比大小，大于maxSum就update sum最大值，
  // Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  // Output: 6
  // Explanation: The subarray[4, -1, 2, 1] has the largest sum 6.

  //nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  //currnetSum: -2  1  -2       4   3       5   6   1        5
  // maxSum:    -2  1   1(不变)  4   4（不变）5   6   6（不变） 6（不变）
  
  // function maxSubArray(nums) {
  //   if (nums.length === 0) {
  //     return 0
  //   }
  //   if (nums.length === 1) {
  //     return nums[0]
  //   }
  //   let currentSum = nums[0]
  //   let maxSum = nums[0]
  //   for (let i = 1; i < nums.length; i++) {
  //     currentSum = Math.max(nums[i], nums[i] + currentSum)
  //     maxSum = Math.max(maxSum, currentSum)
  //   }
  //   return maxSum

  // }

  // ----------------------------------00066:Plus One---------------------------------- 

// You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer.The digits are ordered from most significant to least significant in left - to - right order.The large integer does not contain any leading 0's.
// Increment the large integer by one and return the resulting array of digits.

//  Example 1:
//   Input: digits = [1, 2, 3]
//   Output: [1, 2, 4]
//   Explanation: The array represents the integer 123.Incrementing by one gives 123 + 1 = 124.
//   Thus, the result should be[1, 2, 4].

//  Example 2:

//   Input: digits = [9]
//   Output: [1, 0]
//   Explanation: The array represents the integer 9.Incrementing by one gives 9 + 1 = 10.
//   Thus, the result should be[1, 0].
// O(N) Time complexity. O(1) Space complexity.
 
  // function plusOne(digits) {
  //   for (let i = digits.length - 1; i >= 0; i--) {
  //     if (digits[i] < 9) {
  //       digits[i]++
  //       return digits
  //     } else {
  //       digits[i] = 0
  //     }

  //   }
  //   digits.unshift(1)
  //   return digits

  // }
  // ----------------------------------00088:Merge Sorted Array---------------------------------- 
//就是给了两个array（nums1,nums2)这两个array都是 non-decreasing order.再给两个指定的index（m,n)分别对应两个array的
//的前几个number，在原来的nums1中从m开始补上nums2中的n个数字，且最后return的origin nums1中所有的数字都是 non-decreasing order
// Input: nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3
// Output: [1, 2, 2, 3, 5, 6]
//Explanation: The arrays we are merging are[1, 2, 3] and[2, 5, 6].
//The result of the merge is[1, 2, 2, 3, 5, 6] with the underlined elements coming from nums1.
  //方法1，能做出来，但是not efficient
// function merge(nums1, m, nums2, n) {
//     nums1.splice(m, n, ...nums2)
//     return nums1.sort((a, b) => a - b)

//   }

//方法2:  最坏的状况O(N) Time complexity.     O(1) Space complexity.
//主要的解题思路是因为两个array都是递增的，所以最大的都排在最后面，为了将两个array按照大小的顺序进行排列的话，
//那就用两边最大的number进行比较，依次在origin array（nums1)的后面，从后往前放置比较后得到的最大的数

  // function merge(nums1, m, nums2, n) {
  //     let first = m - 1//找到nums1中的最后一个number
  //   let second = n - 1//找到nums2中的最后一个number
  //   let i = m + n - 1//找到nums1中的最后一个空位
  //   //因为是将num2中的数字加入到num1中，所以比较次数就是按照second来确定
  //   while (second >= 0) {
  //     if (first >= 0 && nums1[first] > nums2[second]) {
  //       nums1[i] = nums1[first];
  //       first--;
  //     } else {
  //       nums1[i] = nums2[second];
  //       second--;
  //     }
  //     i--;
  //   }
  //   return nums1;
  //   //只限定first >= 0而不限定second的原因是之前while loop中已经限定过
  //   //second，当n=0时，second=-1,所以无法进入while loop，最后结果就是原来的num1
      


    // }

    // ----------------------------------00118:Pascals Triangle---------------------------------- 
  //踢出最开始的两行，后面的每一行（除了第一和最后一个number以外，中间的每个数字都是上一行的前一个数和后一个数相加）
  //   function generate (numRows) {
  //   if (numRows === 0) return []
  //   if (numRows === 1) return [[1]]

  //   let triangle = [[1]]
  //   for (let i = 1; i < numRows; i++) {
  //     let prevRow = triangle[i - 1]
  //     let curRow = []
  //     curRow.push(1)
  //     for (let j = 1; j < prevRow.length; j++) {
  //       curRow[j] = prevRow[j] + prevRow[j - 1]

  //     }
  //     curRow.push(1)
  //     triangle.push(curRow)
  //   }
  //   return triangle

  // };

   // ----------------------------------00118:Pascals Triangle 2 ---------------------------------- 
//就return 指定的一行row   
//方法1:按照之前的逻辑思维---> O(N^2) Time complexity. 
  // function generate(rowIndex) {
  //   if (rowIndex === 0) return [1]
  //       let trangle = [[1], [1, 1]]
  //       for (let i = 2; i <= rowIndex; i++) {
  //         let preRow = trangle[i - 1]
  //         let curRow = []
  //         curRow.push(1)
  //         for (let j = 1; j < preRow.length; j++) {
  //           curRow[j] = preRow[j - 1] + preRow[j]
  //         }
  //         curRow.push(1)
  //         trangle.push(curRow)

  //       }
  //       return trangle.pop()

  //     };

//方法2，利用Pascals Triangle中每个数值都和前一个数相关联，有公式，记住公式就可以了
//O(n) Time/space complexity


      // function generate(rowIndex) {
      //   const row = new Array(rowIndex + 1).fill(0);//创建一个比rowIndex更多一个item的array，因为发现每一排都会比rowIndex多一个
      //   row[0] = 1; // 第一项固定为 1
      //   for (let i = 1; i <= rowIndex; i++) {
      //     row[i] = row[i - 1] * (rowIndex - i + 1) / i;//这个就是公式，一个个计算每一个number
      //   }
      //   return row;

      // }

    // ----------------------------------00228. Summary Ranges ---------------------------------- 
//You are given a sorted unique integer array nums.A range[a, b] is the set of all integers from a to b(inclusive).
//Return the smallest sorted list of ranges that cover all the numbers in the array exactly.That is, each element of 
//nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.
//Each range[a, b] in the list should be output as:
// "a->b" if a != b
//"a" if a == b
//其实就是在一个升序的array中对于单独，连续，和重复的item进行整合
//Input: nums = [0,2,3,4,6,8,9]
//Output: ["0", "2->4", "6", "8->9"]
  // Explanation: The ranges are:
  // [0, 0]-- > "0"
  // [2, 4]-- > "2->4"
  // [6, 6]-- > "6"
  // [8, 9]-- > "8->9"
   
  // function summaryRanges(nums){
  //   let output=[]
  //   for(let i=0;i<nums.length;i++){
  //     let item=nums[i]
  //     while(nums[i]+1===nums[i+1]&& i+1<nums.length){
  //       i++

  //     }
  //     if(item!==nums[i]){
  //       let res = item + '->' + nums[i]
  //       output.push(res)
  //     }else{
  //       output.push(item.toString())
  //     }
      
  //   }
  //   return output 
    
  // }

// ----------------------------------00283. Move Zeroes ---------------------------------- 
//Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
//Note that you must do this in -place without making a copy of the array.
//意思就是说在一个array中，将‘0’放在array的最后，其他的以此往前排，并且就在origin array中进行修改
 //Input: nums = [0,1,0,3,12]
 // Output: [1, 3, 12, 0, 0] 
//O(n) Time complexity     O(1)Space complexity
  // function moveZeroes(nums) {
  //   let left = 0
  //   let right = 0
  //   while (right < nums.length) {
  //     if (nums[right] !== 0) {
  //       [nums[left], nums[right]] = [nums[right], nums[left]]// flip two item
  //       left++
  //     }
  //     right++
  //   }
  //   return nums

  // };

  // ----------------------------------00414. Third Maximum Number ---------------------------------- 
  
  //Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.
  //就是找到array中的第三大的数，找不到就找最大的数
  //Input: nums = [2,2,3,1]
  // Output: 1
  //Explanation:
// The first distinct maximum is 3.
// The second distinct maximum is 2(both 2's are counted together since they have the same value).
// The third distinct maximum is 1.
// O(n) time complexity
// -Infinity 初始值最小的情况
  // function thirdMax (nums) {
  //   let a = -Infinity, b = -Infinity, c = -Infinity 
  //   for (let item of nums) {
  //     if (item > a) {
  //       c = b
  //       b = a
  //       a = item
  //     } else if (item < a && item > b) {
  //       c = b
  //       b = item
  //     } else if (item < b && item > c) {
  //       c = item
  //     }
  //   }
  //   return c === -Infinity ? a : c


  // };
   // ----------------------------------00448. Find All Numbers Disappeared in an Array ---------------------------------- 
  //Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.
  //升级要求：Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
  //这个题的大体意思就是说一个在一个[1,n]的array中找到missing items
  
  //Example 1:
  //Input: nums = [4, 3, 2, 7, 8, 2, 3, 1]
  //Output: [5, 6]
  //方法1:是create一个set 集，用set.has(item)这种O(1)的方式查找。但是这个方法会引入一个新的space，所以不是最优解
  // function findDisappearedNumbers (nums) {
  //   let notAppear = []
    //     let set=new Set(nums)
    //     for(let i=1;i<=nums.length;i++){
    //         if(!set.has(i)){
    //             notAppear.push(i)
    //         }

    //     }
    //     return notAppear

  //}
//方法2:为了不创建新的数集，就只能在原来的nums进行修改，
//观察发现将[1,n]中所有的item都-1，对应的就是所有items的index集[0,n-1]，然后对每个index进行标记（标为负数），
//最后只要查看哪些没有标记的index，+1就是missing item
  // function findDisappearedNumbers(nums) {
  //   let res=[]
  //    // 标记数组中出现的数字(设为负数)
  //   for(let item of nums){
  //     let index=Math.abs(item)-1// 获取索引
  //     if(nums[index]>0){
  //       nums[index]= -nums[index] // 将对应位置的值变为负数
  //     }
  //   }
  //       // 找到所有未标记的索引
  //   for(let i=0;i<nums.length;i++ ){
  //     if(nums[i]>0){
  //       res.push(i+1)// 未标记的位置即为缺失的数字
  //     }
  //   }
  //   return res

  // }
     // ----------------------------------00561. Array Partition---------------------------------- 
  //Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) 
  //such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.
//     Input: nums = [1, 4, 3, 2]
//     Output: 4
//     Explanation: All possible pairings(ignoring the ordering of elements) are:
//     1.(1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
//     2.(1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
//     3.(1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4 只有这重non-decrease的排列方式才能得到最大的min
// So the maximum possible sum is 4.

  //这一题主要是理解问题，要取得每pair的最小值，但是又要sum最大，
  //唯一的方法就是将其从小到大排列，这样就可以保证每个pair中的最小值最大

  // function arrayPairSum (nums) {
      
  //     let sorted = nums.sort((a, b) => a - b)
  //     let res = 0
  //     for (let i = 0; i < sorted.length - 1; i += 2) {
  //       res += sorted[i]
  //     }
  //     return res
  //   };

    // ----------------------------------00605. Can Place Flowers----------------------------------
      //You have a long flowerbed in which some of the plots are planted, and some are not. However, 
      //flowers cannot be planted in adjacent plots.
      //Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, 
      //and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no - adjacent - flowers rule
      // and false otherwise.
      //意思就是说看到0的两边都是0，那么就可以插一个🌹，
      //Input: flowerbed = [1,0,0,0,1], n = 2
       // Output: false
//方法1:
       // function canPlaceFlowers (flowerbed, n) {
        //     if (flowerbed.length===1&&flowerbed[0]===0&&n===1) return true
        //     let count=0
        //     for(let i=0;i<flowerbed.length;i++){
        //         if(flowerbed[i]===0){
        //             if(i===0){
        //                 if(flowerbed[i+1]===0){
        //                     flowerbed[i]=1
        //                     count++

        //                 }
        //             }else if(i===flowerbed.length-1){
        //                 if(flowerbed[i-1]===0){
        //                     flowerbed[i]=1
        //                     count++
        //                 }

        //             }else{
        //                 if(flowerbed[i-1]===0&&flowerbed[i+1]===0){
        //                     flowerbed[i]=1
        //                     count++
        //                 }
        //             }
        //         }
        //     }
        //     return count>=n
        // };
//方法2:也没引入新的变量进行store，而且一个for loop也包含了【】两边的item的情况

        //  function canPlaceFlowers(flowerbed, n) {
        //   for (let i = 0; i < flowerbed.length; i++) {
        //     if (flowerbed[i] === 0) {
        //       if (flowerbed[i - 1] !== 1 && flowerbed[i + 1] !== 1) {
        //         n--
        //         flowerbed[i] = 1
        //       }
        //     }
        //   }
        
        //   return n <= 0


        // };
//---------------628. Maximum Product of Three Numbers---------------
//Given an integer array nums, find three numbers whose product is maximum and return the maximum product.
 //这道题就是求一个array中哪三个数相乘得到最大值
 //主要明确，有两种情况，一种是全部为正整数，一种就是存在负数的情况
 //所以先对array进行从小到大的排序，然后对最大的正整数相乘，然后再对前两个负数相乘，得到的正数和最后的一项正数相乘，比较两个数的大小，取最大的那个
// function  maximumProduct (nums) {
//     let leng = nums.length
//     let sorted = nums.sort((a, b) => a - b)
//     pro1 = sorted[leng - 1] * sorted[leng - 2] * sorted[leng - 3]
//     pro2 = sorted[0] * sorted[1] * sorted[leng - 1]
//     return Math.max(pro1, pro2)

//   };

  //---------------643. Maximum Average Subarray I---------------
  //You are given an integer array nums consisting of n elements, and an integer k.
//Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value.
//Any answer with a calculation error less than 10 - 5 will be accepted.
  // Input: nums = [1, 12, -5, -6, 50, 3], k = 4
  // Output: 12.75000
  // Explanation: Maximum average is(12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
  //其实这个问题用 滑动窗口算法。 滑动窗口只需计算第一个长度为 k 的子数组的和，之后每次移动窗口时，
  //只需在前一个窗口和的基础上加上一个新元素，减去一个旧元素，从而将复杂度降低到 O(n)

// function findMaxAverage (nums, k) {
//     let sum = 0
//     for (let i = 0; i < k; i++) {
//       sum += nums[i]
//     }
//     let max = sum
//     for (let j = k; j < nums.length; j++) {
//       sum = sum - nums[j - k] + nums[j]
//       max = Math.max(sum, max)
//     }

//     return max / k
//   };

  //---------------661. Image Smoother---------------
  //An image smoother is a filter of the size 3 x 3 that can be applied to each cell
  // of an image by rounding down the average of the cell and the eight surrounding cells 
  //(i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding 
  //cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).
  //Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.
  //这道题其实就是要理解固定的 3 x 3的方格中所有存在的item的平均值放入原来的item中，组成一个新的array，
  //所以解决方法就是loop这个matrix array，对每个item进行判定周边的3 x 3方格所包含的items
  // function imageSmoother  (img) {
  //   const rows = img.length;       // 矩阵的行数
  //   const cols = img[0].length;    // 矩阵的列数

  //   // 初始化结果矩阵 O（m*n）
  //   const res = Array.from({ length: rows }, () => Array(cols).fill(0));

  //   // 遍历矩阵的每个单元格
  //   for (let y = 0; y < rows; y++) {
  //     for (let x = 0; x < cols; x++) {
  //       let sum = 0;         // 邻居值的和
  //       let count = 0;       // 有效邻居的数量

  //       // 遍历 3×3 范围
  //       for (let i = -1; i <= 1; i++) {
  //         for (let j = -1; j <= 1; j++) {
  //           const newY = y + i;
  //           const newX = x + j;

  //           // 检查边界条件
  //           if (newY >= 0 && newY < rows && newX >= 0 && newX < cols) {
  //             sum += img[newY][newX];
  //             count++;
  //           }
  //         }
  //       }

  //       // 计算平均值并向下取整
  //       res[y][x] = Math.floor(sum / count);
  //     }
  //   }

  //   return res;

  // };
//-------------674. Longest Continuous Increasing Subsequence----------------
  //方法1
// function findLengthOfLCIS (nums) {
//     let max = 1
//     let count = 1
//     let left = nums[0]
//     for (let i = 1; i < nums.length; i++) {
//       if (nums[i] > left) {
//         count++

//       } else {
//         if (count > max) {
//           max = count
//         }
//         count = 1


//       }
//       left = nums[i]

//     }
//     return Math.max(max, count)

//   };
  //方法2
  // function findLengthOfLCIS(nums) {
  //     if (nums.length === 0) {
  //         return 0;
  //     }

  //     let res = 1, length = 1;

  //     for (let i = 1; i < nums.length; i++) {
  //         if (nums[i] > nums[i - 1]) {
  //             length++;
  //         } else {
  //             res = Math.max(res, length);
  //             length = 1;
  //         }
  //     }

  //     return Math.max(res, length);
  // }
//--------------------697. Degree of an Array-----------------------
//Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.
//Your task is to find the smallest possible length of a(contiguous) subarray of nums, that has the same degree as nums.
  // Input: nums = [1, 2, 2, 3, 1, 4, 2]
  // Output: 6
  // Explanation: 
  // The degree is 3 because the element 2 is repeated 3 times.
  //   So[2, 2, 3, 1, 4, 2] is the shortest subarray, therefore returning 6.
//这道题主要是结合了Map()和解构赋值语法(destructuring assignment)的用法
//通过创建一个map,里面包含很多的key-value pairs，value=[count,startIndex,endIndex]
//最后再找到map中count最大的value，得到最短的subarray
  // function findShortestSubArray(nums) {
  //   let map = new Map()
  //   let freq = 0
  //   let smallest = nums.length

  //   for (let i = 0; i < nums.length; i++) {
  //     let num = nums[i]
  //     if (!map.has(num)) {
  //       map.set(num, [1, i, i])
  //     } else {
  //       let [count, start, _] = map.get(num)
  //       map.set(num, [count + 1, start, i])
  //     }
  //     freq = Math.max(freq, map.get(num)[0])

  //   }
  //   for (let [_, values] of map) {
  //     let [c, s, e] = values
  //     if (c === freq) {
  //       smallest = Math.min(smallest, e - s + 1)

  //     }
  //   }
  //   return smallest

  // };

  //-----------------724. Find Pivot Index----------------------
  //Given an array of integers nums, calculate the pivot index of this array.
//The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.
//If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left.This also applies to the right edge of the array.
//Return the leftmost pivot index.If no such index exists, return -1.
 //就是找到一个item，item左边的sum 和右边的sum 相等，return item的index
  //方法1:
  // function  pivotIndex(nums) {


  //     for (let i = 0; i < nums.length; i++) {
  //       let left = 0
  //       for (let l = 0; l < i; l++) {
  //         left += nums[l]
  //       }
  //       let right = 0
  //       for (let j = i + 1; j < nums.length; j++) {
  //         right += nums[j]
  //       }
  //       if (left === right) {
  //         return i
  //       }

  //     }
  //     return -1

  //   };
  //   //方法2 这种方式更快
  //   function pivotIndex(nums) {
  //       if (nums.length <= 0) {
  //         return -1;
  //       }

  //       let sum = 0, leftSum = 0;

  //       // 计算数组总和
  //       for (const num of nums) {
  //         sum += num;
  //       }

  //       // 遍历数组，寻找枢轴索引
  //       for (let index = 0; index < nums.length; index++) {
  //         const num = nums[index];
  //         if (leftSum * 2 + num === sum) {
  //           return index; // 找到枢轴索引
  //         }
  //         leftSum += num;
  //       }

  //       return -1; // 未找到枢轴索引
  //     }

  //     // 示例用法
  //     console.log(pivotIndex([1, 7, 3, 6, 5, 6])); // 输出: 3
  //     console.log(pivotIndex([1, 2, 3]));          // 输出: -1
  //     console.log(pivotIndex([2, 1, -1]));         // 输出: 0

  //-----------------746. Min Cost Climbing Stairs----------------------
  // You are given an integer array cost where cost[i] is the cost of ith step on a staircase.Once you pay the cost, you can either climb one or two steps.
  // You can either start from the step with index 0, or the step with index 1.
  // Return the minimum cost to reach the top of the floor.
  // Input: cost = [10, 15, 20]
  // Output: 15
  // Explanation: You will start at index 1. - Pay 15 and climb two steps to reach the top.
  // The total cost is 15.
//这道题和70题很像,都是关于爬楼的问题
// function  minCostClimbingStairs (cost) {
//       cost.push(0)
//       for (let i = cost.length - 3; i >= 0; i--) {
//         cost[i] = Math.min(cost[i] + cost[i + 1], cost[i] + cost[i + 2])
//       }
//       return Math.min(cost[0], cost[1])
//     };
//-------------------------------70. Climbing Stairs-----------------------------
//解答视频：https://www.youtube.com/watch?v=Y0lT9Fck7qI 
//You are climbing a staircase.It takes n steps to reach the top.
//Each time you can either climb 1 or 2 steps.In how many distinct ways can you climb to the top ?
//Input: n = 3
//Output: 3
//Explanation: There are three ways to climb to the top.
//1. 1 step + 1 step + 1 step
//2. 1 step + 2 steps
//3. 2 steps + 1 step

// function climbStairs  (n) {
//     let one = 1, two = 1
//     for (let i = 0; i < n - 1; i++) {
//       let temp = one
//       one = one + two
//       two = temp
//     }
//     return one
//   };
//-----------------------766. Toeplitz Matrix-----------------
//Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.
//A matrix is Toeplitz if every diagonal from top - left to bottom - right has the same elements
//给出一个矩阵，要求判断矩阵所有对角斜线上的数字是否都是一个数字。
 </script>

</body>

</html>