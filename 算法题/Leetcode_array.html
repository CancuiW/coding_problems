<!DOCTYPE html>
<html lang="en">

<head>
  <title>Web App</title>
  <style>
    
   
      
    
  </style>
</head>

<body>
  
  
  <script>
   
// ----------------------------------0001:Two Sum----------------------------------
// æ„æ€å°±æ˜¯è¯´è¦ä»ä¸€ä¸ªarrayä¸­æ‰¾åˆ°"å”¯ä¸€"ä¸€å¯¹æ•°å­—ï¼ˆa,b),a+b=target
// è¿”å›çš„æ˜¯(a,b)ç›¸å¯¹åº”çš„index
// Input: nums = [3,2,4], target = 6 // 3:0,4:1,2:2
// Output: [1, 2]

//   æœ€ä¼˜çš„åšæ³•æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)
    // function twoSum(nums, target) {
    //     const map = {};

    //     for (let i = 0; i < nums.length; i++) {
    //         const another = target - nums[i];
    //         if (another in map) {
    //             return [map[another], i];
    //         }
    //         map[nums[i]] = i;
    //     }

    //     return null;
    // }

  // ----------------------------------000167. Two Sum II - Input Array Is Sorted----------------------------------
//ä¸€ä¸ªå‡åºçš„arrayï¼Œæ‰¾åˆ°å…¶ä¸­ä¸¤ä¸ªnum1+num2=target.return ä¸¤ä¸ªindex+1
//Input: numbers = [2, 7, 11, 15], target = 9
//Output: [1, 2]
//Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
//æ–¹æ³•1:æŒ‰ç…§0001:Two Sumçš„æ€è·¯ï¼Œåªéœ€è¦å°†å‚¨å­˜çš„index+1


//æ–¹æ³•2:åŒæŒ‡é’ˆï¼ˆå·¦å³ä¸¤è¾¹å‘ä¸­é—´é æ‹¢ï¼‰æ–¹æ³•éå¸¸é«˜æ•ˆï¼Œç‰¹åˆ«é€‚ç”¨äºå·²æ’åºçš„æ•°ç»„ä¸­å¯»æ‰¾æ»¡è¶³æ¡ä»¶çš„ä¸¤ä¸ªå…ƒç´ çš„é—®é¢˜ã€‚
  // function twoSum167(numbers, target) {
  //    let i = 0, j = numbers.length - 1;
  //   while (i < j) {
  //     if (numbers[i] + numbers[j] === target) {
  //       return [i + 1, j + 1]; // è¿”å›çš„æ˜¯ 1 åŸºç´¢å¼•
  //     }
  //     if (numbers[i] + numbers[j] < target) {
  //       i++;
  //     } else {
  //       j--;
  //     }
  //   }
  //   return null;
  // }



  // ----------------------------------00026:Remove Duplicates from Sorted Array----------------------------------
  // é¢˜ç›®æ¡ä»¶ï¼šarrayä¸æ˜¯ä¸€ä¸ªé™åºçš„array
  //ç»™å®šä¸€ä¸ªæœ‰åºæ•°ç»„ nums(ä»å°åˆ°å¤§æ’åˆ—ï¼Œæ‰€ä»¥é‡å¤é¡¹è‚¯å®šæ˜¯åœ¨æ—è¾¹ï¼‰ï¼Œå¯¹æ•°ç»„ä¸­çš„å…ƒç´ è¿›è¡Œå»é‡ï¼Œä½¿å¾—åŸæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ åªæœ‰ä¸€ä¸ªã€‚æœ€åè¿”å›å»é‡ä»¥åæ•°ç»„çš„é•¿åº¦å€¼ã€‚
  // éš¾ç‚¹ï¼šå°±æ˜¯returnçš„è¿˜æ˜¯åŸæ¥çš„arrayï¼ŒreturnåŸæ¥arrayä¸­å”¯ä¸€çš„itemçš„length
  //[0,0,1,1,1,2,2,3,3,4]
  //[0,1,2,3,4]-->return 5  
//åˆ†æï¼š
  
  //           i
  //[0,0,1,1,1,2,2,3,3,4]
  //                   c
  // function removeDuplicates(nums) {
  //     if (nums.length === 0) {
  //       return 0;
  //     }

  //     let insertIndex = 1
  //     for(let current =0; current <nums.length-1; current++){
  //       if(nums[current]!==nums[current+1]){
  //         nums[insertIndex] = nums[current + 1]
  //         insertIndex++
  //       }
  //     }
  //     return insertIndex

      
  //   }
   // ----------------------------------00027:Remove Element----------------------------------
   //è¿™ä¸€é¢˜å’Œ26å·ç›¸ä¼¼ï¼Œä¸åŒçš„æ˜¯åˆ é™¤çš„æ˜¯æŒ‡å®šçš„number
  //     function removeElement(nums, val){

  //   let index=0
  //   for(let i=0;i<nums.length;i++){
  //     if(nums[i]!==val){
  //       nums[index]=nums[i]
  //       index++
  //     }

  //   }

  //  }
 // ----------------------------------00035:Search Insert Position---------------------------------- 
//è¿™ä¸€é¢˜æ˜¯ç»å…¸çš„äºŒåˆ†æœç´¢çš„å˜ç§é¢˜ï¼Œåœ¨æœ‰åºæ•°ç»„ä¸­æ‰¾åˆ°æœ€åä¸€ä¸ªæ¯” target å°çš„å…ƒç´ ã€‚write an algorithm with O(log n) runtime complexity.
  // function searchInsert(nums, target){
  //   let low = 0, high = nums.length - 1;

  //   while (low <= high) {
  //     let mid = low + ((high - low) >> 1);

  //     if (nums[mid] >= target) {
  //       high = mid - 1;
  //     } else {
  //       if (mid === nums.length - 1 || nums[mid + 1] >= target) {
  //         return mid + 1;
  //       }
  //       low = mid + 1;
  //     }
  //   }

  //   return 0;

  // }

  // function searchInsert(nums, target) {
  //     let low = 0, high = nums.length - 1;

  //     while (low <= high) {
  //       let mid = low + Math.floor((high - low) / 2);

  //       if (nums[mid] === target) { 
  //         return mid
  //       }
  //       if (nums[mid] > target) { //target åœ¨å·¦åŒºé—´ï¼Œæ‰€ä»¥[left, middle - 1]
  //         high = mid - 1
  //       } else {
  //         low = mid + 1  //target åœ¨å³åŒºé—´ï¼Œæ‰€ä»¥[middle + 1, right]
  //       }
  //     }

  //     return low;

  //   }

  // ----------------------------------00053:Maximum Subarray---------------------------------- 
//Given an integer array nums, find the subarray with the largest sum, and return its sum.
// A subarray is a contiguous part of an array
//åˆ†æï¼šå› ä¸ºæœ€åéœ€è¦returnçš„æ˜¯maximum sumï¼Œæ‰€ä»¥ä¸ç”¨ç®¡æ˜¯é‚£å‡ ä¸ªè¿ç»­çš„æ•°å­—ï¼Œåªéœ€è¦ç”¨ä¸€ä¸ª
// max å˜é‡è¿›è¡Œæ¯”è¾ƒè®°å½•.é€»è¾‘æ€ç»´ï¼šæ¯”è¾ƒè‡ªèº«å’Œè‡ªèº«ä¸å‰é¢çš„æ•°å­—ç›¸åŠ è¿›è¡Œæ¯”å¤§å°ï¼Œå¤§äºmaxSumå°±update sumæœ€å¤§å€¼ï¼Œ
  // Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  // Output: 6
  // Explanation: The subarray[4, -1, 2, 1] has the largest sum 6.

  //nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  //currnetSum: -2  1  -2       4   3       5   6   1        5
  // maxSum:    -2  1   1(ä¸å˜)  4   4ï¼ˆä¸å˜ï¼‰5   6   6ï¼ˆä¸å˜ï¼‰ 6ï¼ˆä¸å˜ï¼‰
  
  // function maxSubArray(nums) {
  //   if (nums.length === 0) {
  //     return 0
  //   }
  //   if (nums.length === 1) {
  //     return nums[0]
  //   }
  //   let currentSum = nums[0]
  //   let maxSum = nums[0]
  //   for (let i = 1; i < nums.length; i++) {
  //     currentSum = Math.max(nums[i], nums[i] + currentSum)
  //     maxSum = Math.max(maxSum, currentSum)
  //   }
  //   return maxSum

  // }

  // ----------------------------------00066:Plus One---------------------------------- 

// You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer.The digits are ordered from most significant to least significant in left - to - right order.The large integer does not contain any leading 0's.
// Increment the large integer by one and return the resulting array of digits.

//  Example 1:
//   Input: digits = [1, 2, 3]
//   Output: [1, 2, 4]
//   Explanation: The array represents the integer 123.Incrementing by one gives 123 + 1 = 124.
//   Thus, the result should be[1, 2, 4].

//  Example 2:

//   Input: digits = [9]
//   Output: [1, 0]
//   Explanation: The array represents the integer 9.Incrementing by one gives 9 + 1 = 10.
//   Thus, the result should be[1, 0].
// O(N) Time complexity. O(1) Space complexity.
 
  // function plusOne(digits) {
  //   for (let i = digits.length - 1; i >= 0; i--) {
  //     if (digits[i] < 9) {
  //       digits[i]++
  //       return digits
  //     } else {
  //       digits[i] = 0
  //     }

  //   }
  //   digits.unshift(1)
  //   return digits

  // }
  // ----------------------------------00088:Merge Sorted Array---------------------------------- 
//å°±æ˜¯ç»™äº†ä¸¤ä¸ªarrayï¼ˆnums1,nums2)è¿™ä¸¤ä¸ªarrayéƒ½æ˜¯ non-decreasing order.å†ç»™ä¸¤ä¸ªæŒ‡å®šçš„indexï¼ˆm,n)åˆ†åˆ«å¯¹åº”ä¸¤ä¸ªarrayçš„
//çš„å‰å‡ ä¸ªnumberï¼Œåœ¨åŸæ¥çš„nums1ä¸­ä»må¼€å§‹è¡¥ä¸Šnums2ä¸­çš„nä¸ªæ•°å­—ï¼Œä¸”æœ€åreturnçš„origin nums1ä¸­æ‰€æœ‰çš„æ•°å­—éƒ½æ˜¯ non-decreasing order
// Input: nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3
// Output: [1, 2, 2, 3, 5, 6]
//Explanation: The arrays we are merging are[1, 2, 3] and[2, 5, 6].
//The result of the merge is[1, 2, 2, 3, 5, 6] with the underlined elements coming from nums1.
  //æ–¹æ³•1ï¼Œèƒ½åšå‡ºæ¥ï¼Œä½†æ˜¯not efficient
// function merge(nums1, m, nums2, n) {
//     nums1.splice(m, n, ...nums2)
//     return nums1.sort((a, b) => a - b)

//   }

//æ–¹æ³•2:  æœ€åçš„çŠ¶å†µO(N) Time complexity.     O(1) Space complexity.
//ä¸»è¦çš„è§£é¢˜æ€è·¯æ˜¯å› ä¸ºä¸¤ä¸ªarrayéƒ½æ˜¯é€’å¢çš„ï¼Œæ‰€ä»¥æœ€å¤§çš„éƒ½æ’åœ¨æœ€åé¢ï¼Œä¸ºäº†å°†ä¸¤ä¸ªarrayæŒ‰ç…§å¤§å°çš„é¡ºåºè¿›è¡Œæ’åˆ—çš„è¯ï¼Œ
//é‚£å°±ç”¨ä¸¤è¾¹æœ€å¤§çš„numberè¿›è¡Œæ¯”è¾ƒï¼Œä¾æ¬¡åœ¨origin arrayï¼ˆnums1)çš„åé¢ï¼Œä»åå¾€å‰æ”¾ç½®æ¯”è¾ƒåå¾—åˆ°çš„æœ€å¤§çš„æ•°

  // function merge(nums1, m, nums2, n) {
  //     let first = m - 1//æ‰¾åˆ°nums1ä¸­çš„æœ€åä¸€ä¸ªnumber
  //   let second = n - 1//æ‰¾åˆ°nums2ä¸­çš„æœ€åä¸€ä¸ªnumber
  //   let i = m + n - 1//æ‰¾åˆ°nums1ä¸­çš„æœ€åä¸€ä¸ªç©ºä½
  //   //å› ä¸ºæ˜¯å°†num2ä¸­çš„æ•°å­—åŠ å…¥åˆ°num1ä¸­ï¼Œæ‰€ä»¥æ¯”è¾ƒæ¬¡æ•°å°±æ˜¯æŒ‰ç…§secondæ¥ç¡®å®š
  //   while (second >= 0) {
  //     if (first >= 0 && nums1[first] > nums2[second]) {
  //       nums1[i] = nums1[first];
  //       first--;
  //     } else {
  //       nums1[i] = nums2[second];
  //       second--;
  //     }
  //     i--;
  //   }
  //   return nums1;
  //   //åªé™å®šfirst >= 0è€Œä¸é™å®šsecondçš„åŸå› æ˜¯ä¹‹å‰while loopä¸­å·²ç»é™å®šè¿‡
  //   //secondï¼Œå½“n=0æ—¶ï¼Œsecond=-1,æ‰€ä»¥æ— æ³•è¿›å…¥while loopï¼Œæœ€åç»“æœå°±æ˜¯åŸæ¥çš„num1
      


    // }

    // ----------------------------------00118:Pascals Triangle---------------------------------- 
  //è¸¢å‡ºæœ€å¼€å§‹çš„ä¸¤è¡Œï¼Œåé¢çš„æ¯ä¸€è¡Œï¼ˆé™¤äº†ç¬¬ä¸€å’Œæœ€åä¸€ä¸ªnumberä»¥å¤–ï¼Œä¸­é—´çš„æ¯ä¸ªæ•°å­—éƒ½æ˜¯ä¸Šä¸€è¡Œçš„å‰ä¸€ä¸ªæ•°å’Œåä¸€ä¸ªæ•°ç›¸åŠ ï¼‰
  //   function generate (numRows) {
  //   if (numRows === 0) return []
  //   if (numRows === 1) return [[1]]

  //   let triangle = [[1]]
  //   for (let i = 1; i < numRows; i++) {
  //     let prevRow = triangle[i - 1]
  //     let curRow = []
  //     curRow.push(1)
  //     for (let j = 1; j < prevRow.length; j++) {
  //       curRow[j] = prevRow[j] + prevRow[j - 1]

  //     }
  //     curRow.push(1)
  //     triangle.push(curRow)
  //   }
  //   return triangle

  // };

   // ----------------------------------00118:Pascals Triangle 2 ---------------------------------- 
//å°±return æŒ‡å®šçš„ä¸€è¡Œrow   
//æ–¹æ³•1:æŒ‰ç…§ä¹‹å‰çš„é€»è¾‘æ€ç»´---> O(N^2) Time complexity. 
  // function generate(rowIndex) {
  //   if (rowIndex === 0) return [1]
  //       let trangle = [[1], [1, 1]]
  //       for (let i = 2; i <= rowIndex; i++) {
  //         let preRow = trangle[i - 1]
  //         let curRow = []
  //         curRow.push(1)
  //         for (let j = 1; j < preRow.length; j++) {
  //           curRow[j] = preRow[j - 1] + preRow[j]
  //         }
  //         curRow.push(1)
  //         trangle.push(curRow)

  //       }
  //       return trangle.pop()

  //     };

//æ–¹æ³•2ï¼Œåˆ©ç”¨Pascals Triangleä¸­æ¯ä¸ªæ•°å€¼éƒ½å’Œå‰ä¸€ä¸ªæ•°ç›¸å…³è”ï¼Œæœ‰å…¬å¼ï¼Œè®°ä½å…¬å¼å°±å¯ä»¥äº†
//O(n) Time/space complexity


      // function generate(rowIndex) {
      //   const row = new Array(rowIndex + 1).fill(0);//åˆ›å»ºä¸€ä¸ªæ¯”rowIndexæ›´å¤šä¸€ä¸ªitemçš„arrayï¼Œå› ä¸ºå‘ç°æ¯ä¸€æ’éƒ½ä¼šæ¯”rowIndexå¤šä¸€ä¸ª
      //   row[0] = 1; // ç¬¬ä¸€é¡¹å›ºå®šä¸º 1
      //   for (let i = 1; i <= rowIndex; i++) {
      //     row[i] = row[i - 1] * (rowIndex - i + 1) / i;//è¿™ä¸ªå°±æ˜¯å…¬å¼ï¼Œä¸€ä¸ªä¸ªè®¡ç®—æ¯ä¸€ä¸ªnumber
      //   }
      //   return row;

      // }

    // ----------------------------------00228. Summary Ranges ---------------------------------- 
//You are given a sorted unique integer array nums.A range[a, b] is the set of all integers from a to b(inclusive).
//Return the smallest sorted list of ranges that cover all the numbers in the array exactly.That is, each element of 
//nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.
//Each range[a, b] in the list should be output as:
// "a->b" if a != b
//"a" if a == b
//å…¶å®å°±æ˜¯åœ¨ä¸€ä¸ªå‡åºçš„arrayä¸­å¯¹äºå•ç‹¬ï¼Œè¿ç»­ï¼Œå’Œé‡å¤çš„itemè¿›è¡Œæ•´åˆ
//Input: nums = [0,2,3,4,6,8,9]
//Output: ["0", "2->4", "6", "8->9"]
  // Explanation: The ranges are:
  // [0, 0]-- > "0"
  // [2, 4]-- > "2->4"
  // [6, 6]-- > "6"
  // [8, 9]-- > "8->9"
   
  // function summaryRanges(nums){
  //   let output=[]
  //   for(let i=0;i<nums.length;i++){
  //     let item=nums[i]
  //     while(nums[i]+1===nums[i+1]&& i+1<nums.length){
  //       i++

  //     }
  //     if(item!==nums[i]){
  //       let res = item + '->' + nums[i]
  //       output.push(res)
  //     }else{
  //       output.push(item.toString())
  //     }
      
  //   }
  //   return output 
    
  // }

// ----------------------------------00283. Move Zeroes ---------------------------------- 
//Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
//Note that you must do this in -place without making a copy of the array.
//æ„æ€å°±æ˜¯è¯´åœ¨ä¸€ä¸ªarrayä¸­ï¼Œå°†â€˜0â€™æ”¾åœ¨arrayçš„æœ€åï¼Œå…¶ä»–çš„ä»¥æ­¤å¾€å‰æ’ï¼Œå¹¶ä¸”å°±åœ¨origin arrayä¸­è¿›è¡Œä¿®æ”¹
 //Input: nums = [0,1,0,3,12]
 // Output: [1, 3, 12, 0, 0] 
//O(n) Time complexity     O(1)Space complexity
  // function moveZeroes(nums) {
  //   let left = 0
  //   let right = 0
  //   while (right < nums.length) {
  //     if (nums[right] !== 0) {
  //       [nums[left], nums[right]] = [nums[right], nums[left]]// flip two item
  //       left++
  //     }
  //     right++
  //   }
  //   return nums

  // };

  // ----------------------------------00414. Third Maximum Number ---------------------------------- 
  
  //Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.
  //å°±æ˜¯æ‰¾åˆ°arrayä¸­çš„ç¬¬ä¸‰å¤§çš„æ•°ï¼Œæ‰¾ä¸åˆ°å°±æ‰¾æœ€å¤§çš„æ•°
  //Input: nums = [2,2,3,1]
  // Output: 1
  //Explanation:
// The first distinct maximum is 3.
// The second distinct maximum is 2(both 2's are counted together since they have the same value).
// The third distinct maximum is 1.
// O(n) time complexity
// -Infinity åˆå§‹å€¼æœ€å°çš„æƒ…å†µ
  // function thirdMax (nums) {
  //   let a = -Infinity, b = -Infinity, c = -Infinity 
  //   for (let item of nums) {
  //     if (item > a) {
  //       c = b
  //       b = a
  //       a = item
  //     } else if (item < a && item > b) {
  //       c = b
  //       b = item
  //     } else if (item < b && item > c) {
  //       c = item
  //     }
  //   }
  //   return c === -Infinity ? a : c


  // };
   // ----------------------------------00448. Find All Numbers Disappeared in an Array ---------------------------------- 
  //Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.
  //å‡çº§è¦æ±‚ï¼šCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
  //è¿™ä¸ªé¢˜çš„å¤§ä½“æ„æ€å°±æ˜¯è¯´ä¸€ä¸ªåœ¨ä¸€ä¸ª[1,n]çš„arrayä¸­æ‰¾åˆ°missing items
  
  //Example 1:
  //Input: nums = [4, 3, 2, 7, 8, 2, 3, 1]
  //Output: [5, 6]
  //æ–¹æ³•1:æ˜¯createä¸€ä¸ªset é›†ï¼Œç”¨set.has(item)è¿™ç§O(1)çš„æ–¹å¼æŸ¥æ‰¾ã€‚ä½†æ˜¯è¿™ä¸ªæ–¹æ³•ä¼šå¼•å…¥ä¸€ä¸ªæ–°çš„spaceï¼Œæ‰€ä»¥ä¸æ˜¯æœ€ä¼˜è§£
  // function findDisappearedNumbers (nums) {
  //   let notAppear = []
    //     let set=new Set(nums)
    //     for(let i=1;i<=nums.length;i++){
    //         if(!set.has(i)){
    //             notAppear.push(i)
    //         }

    //     }
    //     return notAppear

  //}
//æ–¹æ³•2:ä¸ºäº†ä¸åˆ›å»ºæ–°çš„æ•°é›†ï¼Œå°±åªèƒ½åœ¨åŸæ¥çš„numsè¿›è¡Œä¿®æ”¹ï¼Œ
//è§‚å¯Ÿå‘ç°å°†[1,n]ä¸­æ‰€æœ‰çš„iteméƒ½-1ï¼Œå¯¹åº”çš„å°±æ˜¯æ‰€æœ‰itemsçš„indexé›†[0,n-1]ï¼Œç„¶åå¯¹æ¯ä¸ªindexè¿›è¡Œæ ‡è®°ï¼ˆæ ‡ä¸ºè´Ÿæ•°ï¼‰ï¼Œ
//æœ€ååªè¦æŸ¥çœ‹å“ªäº›æ²¡æœ‰æ ‡è®°çš„indexï¼Œ+1å°±æ˜¯missing item
  // function findDisappearedNumbers(nums) {
  //   let res=[]
  //    // æ ‡è®°æ•°ç»„ä¸­å‡ºç°çš„æ•°å­—(è®¾ä¸ºè´Ÿæ•°)
  //   for(let item of nums){
  //     let index=Math.abs(item)-1// è·å–ç´¢å¼•
  //     if(nums[index]>0){
  //       nums[index]= -nums[index] // å°†å¯¹åº”ä½ç½®çš„å€¼å˜ä¸ºè´Ÿæ•°
  //     }
  //   }
  //       // æ‰¾åˆ°æ‰€æœ‰æœªæ ‡è®°çš„ç´¢å¼•
  //   for(let i=0;i<nums.length;i++ ){
  //     if(nums[i]>0){
  //       res.push(i+1)// æœªæ ‡è®°çš„ä½ç½®å³ä¸ºç¼ºå¤±çš„æ•°å­—
  //     }
  //   }
  //   return res

  // }
     // ----------------------------------00561. Array Partition---------------------------------- 
  //Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) 
  //such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.
//     Input: nums = [1, 4, 3, 2]
//     Output: 4
//     Explanation: All possible pairings(ignoring the ordering of elements) are:
//     1.(1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
//     2.(1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
//     3.(1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4 åªæœ‰è¿™é‡non-decreaseçš„æ’åˆ—æ–¹å¼æ‰èƒ½å¾—åˆ°æœ€å¤§çš„min
// So the maximum possible sum is 4.

  //è¿™ä¸€é¢˜ä¸»è¦æ˜¯ç†è§£é—®é¢˜ï¼Œè¦å–å¾—æ¯pairçš„æœ€å°å€¼ï¼Œä½†æ˜¯åˆè¦sumæœ€å¤§ï¼Œ
  //å”¯ä¸€çš„æ–¹æ³•å°±æ˜¯å°†å…¶ä»å°åˆ°å¤§æ’åˆ—ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯æ¯ä¸ªpairä¸­çš„æœ€å°å€¼æœ€å¤§

  // function arrayPairSum (nums) {
      
  //     let sorted = nums.sort((a, b) => a - b)
  //     let res = 0
  //     for (let i = 0; i < sorted.length - 1; i += 2) {
  //       res += sorted[i]
  //     }
  //     return res
  //   };

    // ----------------------------------00605. Can Place Flowers----------------------------------
      //You have a long flowerbed in which some of the plots are planted, and some are not. However, 
      //flowers cannot be planted in adjacent plots.
      //Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, 
      //and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no - adjacent - flowers rule
      // and false otherwise.
      //æ„æ€å°±æ˜¯è¯´çœ‹åˆ°0çš„ä¸¤è¾¹éƒ½æ˜¯0ï¼Œé‚£ä¹ˆå°±å¯ä»¥æ’ä¸€ä¸ªğŸŒ¹ï¼Œ
      //Input: flowerbed = [1,0,0,0,1], n = 2
       // Output: false
//æ–¹æ³•1:
       // function canPlaceFlowers (flowerbed, n) {
        //     if (flowerbed.length===1&&flowerbed[0]===0&&n===1) return true
        //     let count=0
        //     for(let i=0;i<flowerbed.length;i++){
        //         if(flowerbed[i]===0){
        //             if(i===0){
        //                 if(flowerbed[i+1]===0){
        //                     flowerbed[i]=1
        //                     count++

        //                 }
        //             }else if(i===flowerbed.length-1){
        //                 if(flowerbed[i-1]===0){
        //                     flowerbed[i]=1
        //                     count++
        //                 }

        //             }else{
        //                 if(flowerbed[i-1]===0&&flowerbed[i+1]===0){
        //                     flowerbed[i]=1
        //                     count++
        //                 }
        //             }
        //         }
        //     }
        //     return count>=n
        // };
//æ–¹æ³•2:ä¹Ÿæ²¡å¼•å…¥æ–°çš„å˜é‡è¿›è¡Œstoreï¼Œè€Œä¸”ä¸€ä¸ªfor loopä¹ŸåŒ…å«äº†ã€ã€‘ä¸¤è¾¹çš„itemçš„æƒ…å†µ

        //  function canPlaceFlowers(flowerbed, n) {
        //   for (let i = 0; i < flowerbed.length; i++) {
        //     if (flowerbed[i] === 0) {
        //       if (flowerbed[i - 1] !== 1 && flowerbed[i + 1] !== 1) {
        //         n--
        //         flowerbed[i] = 1
        //       }
        //     }
        //   }
        
        //   return n <= 0


        // };


  </script>

</body>

</html>