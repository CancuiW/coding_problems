<!DOCTYPE html>
<html lang="en">

<head>
  <title>Web App</title>
  <style>
    
   
      
    
  </style>
</head>

<body>
  
  
  <script>
   
// ----------------------------------0001:Two Sum----------------------------------
// 意思就是说要从一个array中找到"唯一"一对数字（a,b),a+b=target
// 返回的是(a,b)相对应的index
// Input: nums = [3,2,4], target = 6
// Output: [1, 2]

//   最优的做法时间复杂度是 O(n)
    // function twoSum(nums, target) {
    //     const map = {};

    //     for (let i = 0; i < nums.length; i++) {
    //         const another = target - nums[i];
    //         if (another in map) {
    //             return [map[another], i];
    //         }
    //         map[nums[i]] = i;
    //     }

    //     return null;
    // }
  // ----------------------------------00026:Remove Duplicates from Sorted Array----------------------------------
  // 题目条件：array不是一个降序的array
  //给定一个有序数组 nums(从小到大排列，所以重复项肯定是在旁边），对数组中的元素进行去重，使得原数组中的每个元素只有一个。最后返回去重以后数组的长度值。
  // 难点：就是return的还是原来的array，return原来array中唯一的item的length
  //[0,0,1,1,1,2,2,3,3,4]
  //[0,1,2,3,4]-->return 5  
//分析：
  
  //           i
  //[0,0,1,1,1,2,2,3,3,4]
  //                   c
  // function removeDuplicates(nums) {
  //     if (nums.length === 0) {
  //       return 0;
  //     }

  //     let insertIndex = 1
  //     for(let current =0; current <nums.length-1; current++){
  //       if(nums[current]!==nums[current+1]){
  //         nums[insertIndex] = nums[current + 1]
  //         insertIndex++
  //       }
  //     }
  //     return insertIndex

      
  //   }
   // ----------------------------------00027:Remove Element----------------------------------
   //这一题和26号相似，不同的是删除的是指定的number
  //     function removeElement(nums, val){

  //   let index=0
  //   for(let i=0;i<nums.length;i++){
  //     if(nums[i]!==val){
  //       nums[index]=nums[i]
  //       index++
  //     }

  //   }

  //  }
 // ----------------------------------00035:Search Insert Position---------------------------------- 
//这一题是经典的二分搜索的变种题，在有序数组中找到最后一个比 target 小的元素。write an algorithm with O(log n) runtime complexity.
  // function searchInsert(nums, target){
  //   let low = 0, high = nums.length - 1;

  //   while (low <= high) {
  //     let mid = low + ((high - low) >> 1);

  //     if (nums[mid] >= target) {
  //       high = mid - 1;
  //     } else {
  //       if (mid === nums.length - 1 || nums[mid + 1] >= target) {
  //         return mid + 1;
  //       }
  //       low = mid + 1;
  //     }
  //   }

  //   return 0;

  // }

  // function searchInsert(nums, target) {
  //     let low = 0, high = nums.length - 1;

  //     while (low <= high) {
  //       let mid = low + Math.floor((high - low) / 2);

  //       if (nums[mid] === target) { 
  //         return mid
  //       }
  //       if (nums[mid] > target) { //target 在左区间，所以[left, middle - 1]
  //         high = mid - 1
  //       } else {
  //         low = mid + 1  //target 在右区间，所以[middle + 1, right]
  //       }
  //     }

  //     return low;

  //   }

  // ----------------------------------00053:Maximum Subarray---------------------------------- 
//Given an integer array nums, find the subarray with the largest sum, and return its sum.
// A subarray is a contiguous part of an array
//分析：因为最后需要return的是maximum sum，所以不用管是那几个连续的数字，只需要用一个
// max 变量进行比较记录.逻辑思维：比较自身和自身与前面的数字相加进行比大小，大于maxSum就update sum最大值，
  // Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  // Output: 6
  // Explanation: The subarray[4, -1, 2, 1] has the largest sum 6.

  //nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  //currnetSum: -2  1  -2       4   3       5   6   1        5
  // maxSum:    -2  1   1(不变)  4   4（不变）5   6   6（不变） 6（不变）
  
  // function maxSubArray(nums) {
  //   if (nums.length === 0) {
  //     return 0
  //   }
  //   if (nums.length === 1) {
  //     return nums[0]
  //   }
  //   let currentSum = nums[0]
  //   let maxSum = nums[0]
  //   for (let i = 1; i < nums.length; i++) {
  //     currentSum = Math.max(nums[i], nums[i] + currentSum)
  //     maxSum = Math.max(maxSum, currentSum)
  //   }
  //   return maxSum

  // }

  // ----------------------------------00066:Plus One---------------------------------- 

// You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer.The digits are ordered from most significant to least significant in left - to - right order.The large integer does not contain any leading 0's.
// Increment the large integer by one and return the resulting array of digits.

//  Example 1:
//   Input: digits = [1, 2, 3]
//   Output: [1, 2, 4]
//   Explanation: The array represents the integer 123.Incrementing by one gives 123 + 1 = 124.
//   Thus, the result should be[1, 2, 4].

//  Example 2:

//   Input: digits = [9]
//   Output: [1, 0]
//   Explanation: The array represents the integer 9.Incrementing by one gives 9 + 1 = 10.
//   Thus, the result should be[1, 0].
// O(N) Time complexity. O(1) Space complexity.
 
  // function plusOne(digits) {
  //   for (let i = digits.length - 1; i >= 0; i--) {
  //     if (digits[i] < 9) {
  //       digits[i]++
  //       return digits
  //     } else {
  //       digits[i] = 0
  //     }

  //   }
  //   digits.unshift(1)
  //   return digits

  // }
  // ----------------------------------00088:Merge Sorted Array---------------------------------- 
//就是给了两个array（nums1,nums2)这两个array都是 non-decreasing order.再给两个指定的index（m,n)分别对应两个array的
//的前几个number，在原来的nums1中从m开始补上nums2中的n个数字，且最后return的origin nums1中所有的数字都是 non-decreasing order
// Input: nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3
// Output: [1, 2, 2, 3, 5, 6]
//Explanation: The arrays we are merging are[1, 2, 3] and[2, 5, 6].
//The result of the merge is[1, 2, 2, 3, 5, 6] with the underlined elements coming from nums1.
  //方法1，能做出来，但是not efficient
// function merge(nums1, m, nums2, n) {
//     nums1.splice(m, n, ...nums2)
//     return nums1.sort((a, b) => a - b)

//   }

//方法2:  最坏的状况O(N) Time complexity.     O(1) Space complexity.
//主要的解题思路是因为两个array都是递增的，所以最大的都排在最后面，为了将两个array按照大小的顺序进行排列的话，
//那就用两边最大的number进行比较，依次在origin array（nums1)的后面，从后往前放置比较后得到的最大的数

  // function merge(nums1, m, nums2, n) {
  //     let first = m - 1//找到nums1中的最后一个number
  //   let second = n - 1//找到nums2中的最后一个number
  //   let i = m + n - 1//找到nums1中的最后一个空位
  //   //因为是将num2中的数字加入到num1中，所以比较次数就是按照second来确定
  //   while (second >= 0) {
  //     if (first >= 0 && nums1[first] > nums2[second]) {
  //       nums1[i] = nums1[first];
  //       first--;
  //     } else {
  //       nums1[i] = nums2[second];
  //       second--;
  //     }
  //     i--;
  //   }
  //   return nums1;
  //   //只限定first >= 0而不限定second的原因是之前while loop中已经限定过
  //   //second，当n=0时，second=-1,所以无法进入while loop，最后结果就是原来的num1
      


    // }


  </script>

</body>

</html>