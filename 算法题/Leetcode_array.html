<!DOCTYPE html>
<html lang="en">

<head>
  <title>Web App</title>
  <style>
    
   
      
    
  </style>
</head>

<body>
  
  
  <script>
   
// ----------------------------------0001:Two Sum----------------------------------
// 意思就是说要从一个array中找到"唯一"一对数字（a,b),a+b=target
// 返回的是(a,b)相对应的index
// Input: nums = [3,2,4], target = 6
// Output: [1, 2]

//   最优的做法时间复杂度是 O(n)
    // function twoSum(nums, target) {
    //     const map = {};

    //     for (let i = 0; i < nums.length; i++) {
    //         const another = target - nums[i];
    //         if (another in map) {
    //             return [map[another], i];
    //         }
    //         map[nums[i]] = i;
    //     }

    //     return null;
    // }
  // ----------------------------------00026:Remove Duplicates from Sorted Array----------------------------------
  // 题目条件：array不是一个降序的array
  //给定一个有序数组 nums(从小到大排列，所以重复项肯定是在旁边），对数组中的元素进行去重，使得原数组中的每个元素只有一个。最后返回去重以后数组的长度值。
  // 难点：就是return的还是原来的array，return原来array中唯一的item的length
  //[0,0,1,1,1,2,2,3,3,4]
  //[0,1,2,3,4]-->return 5  
//分析：
  
  //           i
  //[0,0,1,1,1,2,2,3,3,4]
  //                   c
  // function removeDuplicates(nums) {
  //     if (nums.length === 0) {
  //       return 0;
  //     }

  //     let insertIndex = 1
  //     for(let current =0; current <nums.length-1; current++){
  //       if(nums[current]!==nums[current+1]){
  //         nums[insertIndex] = nums[current + 1]
  //         insertIndex++
  //       }
  //     }
  //     return insertIndex

      
  //   }
   // ----------------------------------00027:Remove Element----------------------------------
   //这一题和26号相似，不同的是删除的是指定的number
  //     function removeElement(nums, val){

  //   let index=0
  //   for(let i=0;i<nums.length;i++){
  //     if(nums[i]!==val){
  //       nums[index]=nums[i]
  //       index++
  //     }

  //   }

  //  }
 // ----------------------------------00035:Search Insert Position---------------------------------- 
//这一题是经典的二分搜索的变种题，在有序数组中找到最后一个比 target 小的元素。write an algorithm with O(log n) runtime complexity.
  // function searchInsert(nums, target){
  //   let low = 0, high = nums.length - 1;

  //   while (low <= high) {
  //     let mid = low + ((high - low) >> 1);

  //     if (nums[mid] >= target) {
  //       high = mid - 1;
  //     } else {
  //       if (mid === nums.length - 1 || nums[mid + 1] >= target) {
  //         return mid + 1;
  //       }
  //       low = mid + 1;
  //     }
  //   }

  //   return 0;

  // }

  function searchInsert(nums, target) {
      let low = 0, high = nums.length - 1;

      while (low <= high) {
        let mid = low + Math.floor((high - low) /2 );

        if (nums[mid] === target) {
          return mid
        } 
        if(nums[mid] >target){
          high=mid-1
        }else{
          low=mid+1
        }
      }

      return low;

    }
















  </script>

</body>

</html>