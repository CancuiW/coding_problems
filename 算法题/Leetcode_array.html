<!DOCTYPE html>
<html lang="en">

<head>
  <title>Web App</title>
  <style>
    
   
      
    
  </style>
</head>

<body>
  
  
  <script>

    //å‡½æ•°1: åˆå§‹åŒ–ç»“æœçŸ©é˜µ Oï¼ˆm*nï¼‰
    //  const res = Array.from({ length: rows }, () => Array(cols).fill(0));
   
// ----------------------------------0001:Two Sum----------------------------------
// æ„æ€å°±æ˜¯è¯´è¦ä»ä¸€ä¸ªarrayä¸­æ‰¾åˆ°"å”¯ä¸€"ä¸€å¯¹æ•°å­—ï¼ˆa,b),a+b=target
// è¿”å›çš„æ˜¯(a,b)ç›¸å¯¹åº”çš„index
// Input: nums = [3,2,4], target = 6 // 3:0,4:1,2:2
// Output: [1, 2]

//   æœ€ä¼˜çš„åšæ³•æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)
    // function twoSum(nums, target) {
    //     const map = {};

    //     for (let i = 0; i < nums.length; i++) {
    //         const another = target - nums[i];
    //         if (another in map) {
    //             return [map[another], i];
    //         }
    //         map[nums[i]] = i;
    //     }

    //     return null;
    // }

  // ----------------------------------000167. Two Sum II - Input Array Is Sorted----------------------------------
//ä¸€ä¸ªå‡åºçš„arrayï¼Œæ‰¾åˆ°å…¶ä¸­ä¸¤ä¸ªnum1+num2=target.return ä¸¤ä¸ªindex+1
//Input: numbers = [2, 7, 11, 15], target = 9
//Output: [1, 2]
//Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
//æ–¹æ³•1:æŒ‰ç…§0001:Two Sumçš„æ€è·¯ï¼Œåªéœ€è¦å°†å‚¨å­˜çš„index+1


//æ–¹æ³•2:åŒæŒ‡é’ˆï¼ˆå·¦å³ä¸¤è¾¹å‘ä¸­é—´é æ‹¢ï¼‰æ–¹æ³•éå¸¸é«˜æ•ˆï¼Œç‰¹åˆ«é€‚ç”¨äºå·²æ’åºçš„æ•°ç»„ä¸­å¯»æ‰¾æ»¡è¶³æ¡ä»¶çš„ä¸¤ä¸ªå…ƒç´ çš„é—®é¢˜ã€‚
  // function twoSum167(numbers, target) {
  //    let i = 0, j = numbers.length - 1;
  //   while (i < j) {
  //     if (numbers[i] + numbers[j] === target) {
  //       return [i + 1, j + 1]; // è¿”å›çš„æ˜¯ 1 åŸºç´¢å¼•
  //     }
  //     if (numbers[i] + numbers[j] < target) {
  //       i++;
  //     } else {
  //       j--;
  //     }
  //   }
  //   return null;
  // }



  // ----------------------------------00026:Remove Duplicates from Sorted Array----------------------------------
  // é¢˜ç›®æ¡ä»¶ï¼šarrayä¸æ˜¯ä¸€ä¸ªé™åºçš„array
  //ç»™å®šä¸€ä¸ªæœ‰åºæ•°ç»„ nums(ä»å°åˆ°å¤§æ’åˆ—ï¼Œæ‰€ä»¥é‡å¤é¡¹è‚¯å®šæ˜¯åœ¨æ—è¾¹ï¼‰ï¼Œå¯¹æ•°ç»„ä¸­çš„å…ƒç´ è¿›è¡Œå»é‡ï¼Œä½¿å¾—åŸæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ åªæœ‰ä¸€ä¸ªã€‚æœ€åè¿”å›å»é‡ä»¥åæ•°ç»„çš„é•¿åº¦å€¼ã€‚
  // éš¾ç‚¹ï¼šå°±æ˜¯returnçš„è¿˜æ˜¯åŸæ¥çš„arrayï¼ŒreturnåŸæ¥arrayä¸­å”¯ä¸€çš„itemçš„length
  //[0,0,1,1,1,2,2,3,3,4]
  //[0,1,2,3,4]-->return 5  
//åˆ†æï¼š
  
  //           i
  //[0,0,1,1,1,2,2,3,3,4]
  //                   c
  // function removeDuplicates(nums) {
  //     if (nums.length === 0) {
  //       return 0;
  //     }

  //     let insertIndex = 1
  //     for(let current =0; current <nums.length-1; current++){
  //       if(nums[current]!==nums[current+1]){
  //         nums[insertIndex] = nums[current + 1]
  //         insertIndex++
  //       }
  //     }
  //     return insertIndex

      
  //   }
   // ----------------------------------00027:Remove Element----------------------------------
   //è¿™ä¸€é¢˜å’Œ26å·ç›¸ä¼¼ï¼Œä¸åŒçš„æ˜¯åˆ é™¤çš„æ˜¯æŒ‡å®šçš„number
  //     function removeElement(nums, val){

  //   let index=0
  //   for(let i=0;i<nums.length;i++){
  //     if(nums[i]!==val){
  //       nums[index]=nums[i]
  //       index++
  //     }

  //   }

  //  }
 // ----------------------------------00035:Search Insert Position---------------------------------- 
//è¿™ä¸€é¢˜æ˜¯ç»å…¸çš„äºŒåˆ†æœç´¢çš„å˜ç§é¢˜ï¼Œåœ¨æœ‰åºæ•°ç»„ä¸­æ‰¾åˆ°æœ€åä¸€ä¸ªæ¯” target å°çš„å…ƒç´ ã€‚write an algorithm with O(log n) runtime complexity.
  // function searchInsert(nums, target){
  //   let low = 0, high = nums.length - 1;

  //   while (low <= high) {
  //     let mid = low + ((high - low) >> 1);

  //     if (nums[mid] >= target) {
  //       high = mid - 1;
  //     } else {
  //       if (mid === nums.length - 1 || nums[mid + 1] >= target) {
  //         return mid + 1;
  //       }
  //       low = mid + 1;
  //     }
  //   }

  //   return 0;

  // }

  // function searchInsert(nums, target) {
  //     let low = 0, high = nums.length - 1;

  //     while (low <= high) {
  //       let mid = low + Math.floor((high - low) / 2);

  //       if (nums[mid] === target) { 
  //         return mid
  //       }
  //       if (nums[mid] > target) { //target åœ¨å·¦åŒºé—´ï¼Œæ‰€ä»¥[left, middle - 1]
  //         high = mid - 1
  //       } else {
  //         low = mid + 1  //target åœ¨å³åŒºé—´ï¼Œæ‰€ä»¥[middle + 1, right]
  //       }
  //     }

  //     return low;

  //   }

  // ----------------------------------00053:Maximum Subarray---------------------------------- 
//Given an integer array nums, find the subarray with the largest sum, and return its sum.
// A subarray is a contiguous part of an array
//åˆ†æï¼šå› ä¸ºæœ€åéœ€è¦returnçš„æ˜¯maximum sumï¼Œæ‰€ä»¥ä¸ç”¨ç®¡æ˜¯é‚£å‡ ä¸ªè¿ç»­çš„æ•°å­—ï¼Œåªéœ€è¦ç”¨ä¸€ä¸ª
// max å˜é‡è¿›è¡Œæ¯”è¾ƒè®°å½•.é€»è¾‘æ€ç»´ï¼šæ¯”è¾ƒè‡ªèº«å’Œè‡ªèº«ä¸å‰é¢çš„æ•°å­—ç›¸åŠ è¿›è¡Œæ¯”å¤§å°ï¼Œå¤§äºmaxSumå°±update sumæœ€å¤§å€¼ï¼Œ
  // Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  // Output: 6
  // Explanation: The subarray[4, -1, 2, 1] has the largest sum 6.

  //nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  //currnetSum: -2  1  -2       4   3       5   6   1        5
  // maxSum:    -2  1   1(ä¸å˜)  4   4ï¼ˆä¸å˜ï¼‰5   6   6ï¼ˆä¸å˜ï¼‰ 6ï¼ˆä¸å˜ï¼‰
  
  // function maxSubArray(nums) {
  //   if (nums.length === 0) {
  //     return 0
  //   }
  //   if (nums.length === 1) {
  //     return nums[0]
  //   }
  //   let currentSum = nums[0]
  //   let maxSum = nums[0]
  //   for (let i = 1; i < nums.length; i++) {
  //     currentSum = Math.max(nums[i], nums[i] + currentSum)
  //     maxSum = Math.max(maxSum, currentSum)
  //   }
  //   return maxSum

  // }

  // ----------------------------------00066:Plus One---------------------------------- 

// You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer.The digits are ordered from most significant to least significant in left - to - right order.The large integer does not contain any leading 0's.
// Increment the large integer by one and return the resulting array of digits.

//  Example 1:
//   Input: digits = [1, 2, 3]
//   Output: [1, 2, 4]
//   Explanation: The array represents the integer 123.Incrementing by one gives 123 + 1 = 124.
//   Thus, the result should be[1, 2, 4].

//  Example 2:

//   Input: digits = [9]
//   Output: [1, 0]
//   Explanation: The array represents the integer 9.Incrementing by one gives 9 + 1 = 10.
//   Thus, the result should be[1, 0].
// O(N) Time complexity. O(1) Space complexity.
 
  // function plusOne(digits) {
  //   for (let i = digits.length - 1; i >= 0; i--) {
  //     if (digits[i] < 9) {
  //       digits[i]++
  //       return digits
  //     } else {
  //       digits[i] = 0
  //     }

  //   }
  //   digits.unshift(1)
  //   return digits

  // }
  // ----------------------------------00088:Merge Sorted Array---------------------------------- 
//å°±æ˜¯ç»™äº†ä¸¤ä¸ªarrayï¼ˆnums1,nums2)è¿™ä¸¤ä¸ªarrayéƒ½æ˜¯ non-decreasing order.å†ç»™ä¸¤ä¸ªæŒ‡å®šçš„indexï¼ˆm,n)åˆ†åˆ«å¯¹åº”ä¸¤ä¸ªarrayçš„
//çš„å‰å‡ ä¸ªnumberï¼Œåœ¨åŸæ¥çš„nums1ä¸­ä»må¼€å§‹è¡¥ä¸Šnums2ä¸­çš„nä¸ªæ•°å­—ï¼Œä¸”æœ€åreturnçš„origin nums1ä¸­æ‰€æœ‰çš„æ•°å­—éƒ½æ˜¯ non-decreasing order
// Input: nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3
// Output: [1, 2, 2, 3, 5, 6]
//Explanation: The arrays we are merging are[1, 2, 3] and[2, 5, 6].
//The result of the merge is[1, 2, 2, 3, 5, 6] with the underlined elements coming from nums1.
  //æ–¹æ³•1ï¼Œèƒ½åšå‡ºæ¥ï¼Œä½†æ˜¯not efficient
// function merge(nums1, m, nums2, n) {
//     nums1.splice(m, n, ...nums2)
//     return nums1.sort((a, b) => a - b)

//   }

//æ–¹æ³•2:  æœ€åçš„çŠ¶å†µO(N) Time complexity.     O(1) Space complexity.
//ä¸»è¦çš„è§£é¢˜æ€è·¯æ˜¯å› ä¸ºä¸¤ä¸ªarrayéƒ½æ˜¯é€’å¢çš„ï¼Œæ‰€ä»¥æœ€å¤§çš„éƒ½æ’åœ¨æœ€åé¢ï¼Œä¸ºäº†å°†ä¸¤ä¸ªarrayæŒ‰ç…§å¤§å°çš„é¡ºåºè¿›è¡Œæ’åˆ—çš„è¯ï¼Œ
//é‚£å°±ç”¨ä¸¤è¾¹æœ€å¤§çš„numberè¿›è¡Œæ¯”è¾ƒï¼Œä¾æ¬¡åœ¨origin arrayï¼ˆnums1)çš„åé¢ï¼Œä»åå¾€å‰æ”¾ç½®æ¯”è¾ƒåå¾—åˆ°çš„æœ€å¤§çš„æ•°

  // function merge(nums1, m, nums2, n) {
  //     let first = m - 1//æ‰¾åˆ°nums1ä¸­çš„æœ€åä¸€ä¸ªnumber
  //   let second = n - 1//æ‰¾åˆ°nums2ä¸­çš„æœ€åä¸€ä¸ªnumber
  //   let i = m + n - 1//æ‰¾åˆ°nums1ä¸­çš„æœ€åä¸€ä¸ªç©ºä½
  //   //å› ä¸ºæ˜¯å°†num2ä¸­çš„æ•°å­—åŠ å…¥åˆ°num1ä¸­ï¼Œæ‰€ä»¥æ¯”è¾ƒæ¬¡æ•°å°±æ˜¯æŒ‰ç…§secondæ¥ç¡®å®š
  //   while (second >= 0) {
  //     if (first >= 0 && nums1[first] > nums2[second]) {
  //       nums1[i] = nums1[first];
  //       first--;
  //     } else {
  //       nums1[i] = nums2[second];
  //       second--;
  //     }
  //     i--;
  //   }
  //   return nums1;
  //   //åªé™å®šfirst >= 0è€Œä¸é™å®šsecondçš„åŸå› æ˜¯ä¹‹å‰while loopä¸­å·²ç»é™å®šè¿‡
  //   //secondï¼Œå½“n=0æ—¶ï¼Œsecond=-1,æ‰€ä»¥æ— æ³•è¿›å…¥while loopï¼Œæœ€åç»“æœå°±æ˜¯åŸæ¥çš„num1
      


    // }

    // ----------------------------------00118:Pascals Triangle---------------------------------- 
  //è¸¢å‡ºæœ€å¼€å§‹çš„ä¸¤è¡Œï¼Œåé¢çš„æ¯ä¸€è¡Œï¼ˆé™¤äº†ç¬¬ä¸€å’Œæœ€åä¸€ä¸ªnumberä»¥å¤–ï¼Œä¸­é—´çš„æ¯ä¸ªæ•°å­—éƒ½æ˜¯ä¸Šä¸€è¡Œçš„å‰ä¸€ä¸ªæ•°å’Œåä¸€ä¸ªæ•°ç›¸åŠ ï¼‰
  //   function generate (numRows) {
  //   if (numRows === 0) return []
  //   if (numRows === 1) return [[1]]

  //   let triangle = [[1]]
  //   for (let i = 1; i < numRows; i++) {
  //     let prevRow = triangle[i - 1]
  //     let curRow = []
  //     curRow.push(1)
  //     for (let j = 1; j < prevRow.length; j++) {
  //       curRow[j] = prevRow[j] + prevRow[j - 1]

  //     }
  //     curRow.push(1)
  //     triangle.push(curRow)
  //   }
  //   return triangle

  // };

   // ----------------------------------00118:Pascals Triangle 2 ---------------------------------- 
//å°±return æŒ‡å®šçš„ä¸€è¡Œrow   
//æ–¹æ³•1:æŒ‰ç…§ä¹‹å‰çš„é€»è¾‘æ€ç»´---> O(N^2) Time complexity. 
  // function generate(rowIndex) {
  //   if (rowIndex === 0) return [1]
  //       let trangle = [[1], [1, 1]]
  //       for (let i = 2; i <= rowIndex; i++) {
  //         let preRow = trangle[i - 1]
  //         let curRow = []
  //         curRow.push(1)
  //         for (let j = 1; j < preRow.length; j++) {
  //           curRow[j] = preRow[j - 1] + preRow[j]
  //         }
  //         curRow.push(1)
  //         trangle.push(curRow)

  //       }
  //       return trangle.pop()

  //     };

//æ–¹æ³•2ï¼Œåˆ©ç”¨Pascals Triangleä¸­æ¯ä¸ªæ•°å€¼éƒ½å’Œå‰ä¸€ä¸ªæ•°ç›¸å…³è”ï¼Œæœ‰å…¬å¼ï¼Œè®°ä½å…¬å¼å°±å¯ä»¥äº†
//O(n) Time/space complexity


      // function generate(rowIndex) {
      //   const row = new Array(rowIndex + 1).fill(0);//åˆ›å»ºä¸€ä¸ªæ¯”rowIndexæ›´å¤šä¸€ä¸ªitemçš„arrayï¼Œå› ä¸ºå‘ç°æ¯ä¸€æ’éƒ½ä¼šæ¯”rowIndexå¤šä¸€ä¸ª
      //   row[0] = 1; // ç¬¬ä¸€é¡¹å›ºå®šä¸º 1
      //   for (let i = 1; i <= rowIndex; i++) {
      //     row[i] = row[i - 1] * (rowIndex - i + 1) / i;//è¿™ä¸ªå°±æ˜¯å…¬å¼ï¼Œä¸€ä¸ªä¸ªè®¡ç®—æ¯ä¸€ä¸ªnumber
      //   }
      //   return row;

      // }

    // ----------------------------------00228. Summary Ranges ---------------------------------- 
//You are given a sorted unique integer array nums.A range[a, b] is the set of all integers from a to b(inclusive).
//Return the smallest sorted list of ranges that cover all the numbers in the array exactly.That is, each element of 
//nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.
//Each range[a, b] in the list should be output as:
// "a->b" if a != b
//"a" if a == b
//å…¶å®å°±æ˜¯åœ¨ä¸€ä¸ªå‡åºçš„arrayä¸­å¯¹äºå•ç‹¬ï¼Œè¿ç»­ï¼Œå’Œé‡å¤çš„itemè¿›è¡Œæ•´åˆ
//Input: nums = [0,2,3,4,6,8,9]
//Output: ["0", "2->4", "6", "8->9"]
  // Explanation: The ranges are:
  // [0, 0]-- > "0"
  // [2, 4]-- > "2->4"
  // [6, 6]-- > "6"
  // [8, 9]-- > "8->9"
   
  // function summaryRanges(nums){
  //   let output=[]
  //   for(let i=0;i<nums.length;i++){
  //     let item=nums[i]
  //     while(nums[i]+1===nums[i+1]&& i+1<nums.length){
  //       i++

  //     }
  //     if(item!==nums[i]){
  //       let res = item + '->' + nums[i]
  //       output.push(res)
  //     }else{
  //       output.push(item.toString())
  //     }
      
  //   }
  //   return output 
    
  // }

// ----------------------------------00283. Move Zeroes ---------------------------------- 
//Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
//Note that you must do this in -place without making a copy of the array.
//æ„æ€å°±æ˜¯è¯´åœ¨ä¸€ä¸ªarrayä¸­ï¼Œå°†â€˜0â€™æ”¾åœ¨arrayçš„æœ€åï¼Œå…¶ä»–çš„ä»¥æ­¤å¾€å‰æ’ï¼Œå¹¶ä¸”å°±åœ¨origin arrayä¸­è¿›è¡Œä¿®æ”¹
 //Input: nums = [0,1,0,3,12]
 // Output: [1, 3, 12, 0, 0] 
//O(n) Time complexity     O(1)Space complexity
  // function moveZeroes(nums) {
  //   let left = 0
  //   let right = 0
  //   while (right < nums.length) {
  //     if (nums[right] !== 0) {
  //       [nums[left], nums[right]] = [nums[right], nums[left]]// flip two item
  //       left++
  //     }
  //     right++
  //   }
  //   return nums

  // };

  // ----------------------------------00414. Third Maximum Number ---------------------------------- 
  
  //Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.
  //å°±æ˜¯æ‰¾åˆ°arrayä¸­çš„ç¬¬ä¸‰å¤§çš„æ•°ï¼Œæ‰¾ä¸åˆ°å°±æ‰¾æœ€å¤§çš„æ•°
  //Input: nums = [2,2,3,1]
  // Output: 1
  //Explanation:
// The first distinct maximum is 3.
// The second distinct maximum is 2(both 2's are counted together since they have the same value).
// The third distinct maximum is 1.
// O(n) time complexity
// -Infinity åˆå§‹å€¼æœ€å°çš„æƒ…å†µ
  // function thirdMax (nums) {
  //   let a = -Infinity, b = -Infinity, c = -Infinity 
  //   for (let item of nums) {
  //     if (item > a) {
  //       c = b
  //       b = a
  //       a = item
  //     } else if (item < a && item > b) {
  //       c = b
  //       b = item
  //     } else if (item < b && item > c) {
  //       c = item
  //     }
  //   }
  //   return c === -Infinity ? a : c


  // };
   // ----------------------------------00448. Find All Numbers Disappeared in an Array ---------------------------------- 
  //Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.
  //å‡çº§è¦æ±‚ï¼šCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
  //è¿™ä¸ªé¢˜çš„å¤§ä½“æ„æ€å°±æ˜¯è¯´ä¸€ä¸ªåœ¨ä¸€ä¸ª[1,n]çš„arrayä¸­æ‰¾åˆ°missing items
  
  //Example 1:
  //Input: nums = [4, 3, 2, 7, 8, 2, 3, 1]
  //Output: [5, 6]
  //æ–¹æ³•1:æ˜¯createä¸€ä¸ªset é›†ï¼Œç”¨set.has(item)è¿™ç§O(1)çš„æ–¹å¼æŸ¥æ‰¾ã€‚ä½†æ˜¯è¿™ä¸ªæ–¹æ³•ä¼šå¼•å…¥ä¸€ä¸ªæ–°çš„spaceï¼Œæ‰€ä»¥ä¸æ˜¯æœ€ä¼˜è§£
  // function findDisappearedNumbers (nums) {
  //   let notAppear = []
    //     let set=new Set(nums)
    //     for(let i=1;i<=nums.length;i++){
    //         if(!set.has(i)){
    //             notAppear.push(i)
    //         }

    //     }
    //     return notAppear

  //}
//æ–¹æ³•2:ä¸ºäº†ä¸åˆ›å»ºæ–°çš„æ•°é›†ï¼Œå°±åªèƒ½åœ¨åŸæ¥çš„numsè¿›è¡Œä¿®æ”¹ï¼Œ
//è§‚å¯Ÿå‘ç°å°†[1,n]ä¸­æ‰€æœ‰çš„iteméƒ½-1ï¼Œå¯¹åº”çš„å°±æ˜¯æ‰€æœ‰itemsçš„indexé›†[0,n-1]ï¼Œç„¶åå¯¹æ¯ä¸ªindexè¿›è¡Œæ ‡è®°ï¼ˆæ ‡ä¸ºè´Ÿæ•°ï¼‰ï¼Œ
//æœ€ååªè¦æŸ¥çœ‹å“ªäº›æ²¡æœ‰æ ‡è®°çš„indexï¼Œ+1å°±æ˜¯missing item
  // function findDisappearedNumbers(nums) {
  //   let res=[]
  //    // æ ‡è®°æ•°ç»„ä¸­å‡ºç°çš„æ•°å­—(è®¾ä¸ºè´Ÿæ•°)
  //   for(let item of nums){
  //     let index=Math.abs(item)-1// è·å–ç´¢å¼•
  //     if(nums[index]>0){
  //       nums[index]= -nums[index] // å°†å¯¹åº”ä½ç½®çš„å€¼å˜ä¸ºè´Ÿæ•°
  //     }
  //   }
  //       // æ‰¾åˆ°æ‰€æœ‰æœªæ ‡è®°çš„ç´¢å¼•
  //   for(let i=0;i<nums.length;i++ ){
  //     if(nums[i]>0){
  //       res.push(i+1)// æœªæ ‡è®°çš„ä½ç½®å³ä¸ºç¼ºå¤±çš„æ•°å­—
  //     }
  //   }
  //   return res

  // }
     // ----------------------------------00561. Array Partition---------------------------------- 
  //Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) 
  //such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.
//     Input: nums = [1, 4, 3, 2]
//     Output: 4
//     Explanation: All possible pairings(ignoring the ordering of elements) are:
//     1.(1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
//     2.(1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
//     3.(1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4 åªæœ‰è¿™é‡non-decreaseçš„æ’åˆ—æ–¹å¼æ‰èƒ½å¾—åˆ°æœ€å¤§çš„min
// So the maximum possible sum is 4.

  //è¿™ä¸€é¢˜ä¸»è¦æ˜¯ç†è§£é—®é¢˜ï¼Œè¦å–å¾—æ¯pairçš„æœ€å°å€¼ï¼Œä½†æ˜¯åˆè¦sumæœ€å¤§ï¼Œ
  //å”¯ä¸€çš„æ–¹æ³•å°±æ˜¯å°†å…¶ä»å°åˆ°å¤§æ’åˆ—ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯æ¯ä¸ªpairä¸­çš„æœ€å°å€¼æœ€å¤§

  // function arrayPairSum (nums) {
      
  //     let sorted = nums.sort((a, b) => a - b)
  //     let res = 0
  //     for (let i = 0; i < sorted.length - 1; i += 2) {
  //       res += sorted[i]
  //     }
  //     return res
  //   };

    // ----------------------------------00605. Can Place Flowers----------------------------------
      //You have a long flowerbed in which some of the plots are planted, and some are not. However, 
      //flowers cannot be planted in adjacent plots.
      //Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, 
      //and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no - adjacent - flowers rule
      // and false otherwise.
      //æ„æ€å°±æ˜¯è¯´çœ‹åˆ°0çš„ä¸¤è¾¹éƒ½æ˜¯0ï¼Œé‚£ä¹ˆå°±å¯ä»¥æ’ä¸€ä¸ªğŸŒ¹ï¼Œ
      //Input: flowerbed = [1,0,0,0,1], n = 2
       // Output: false
//æ–¹æ³•1:
       // function canPlaceFlowers (flowerbed, n) {
        //     if (flowerbed.length===1&&flowerbed[0]===0&&n===1) return true
        //     let count=0
        //     for(let i=0;i<flowerbed.length;i++){
        //         if(flowerbed[i]===0){
        //             if(i===0){
        //                 if(flowerbed[i+1]===0){
        //                     flowerbed[i]=1
        //                     count++

        //                 }
        //             }else if(i===flowerbed.length-1){
        //                 if(flowerbed[i-1]===0){
        //                     flowerbed[i]=1
        //                     count++
        //                 }

        //             }else{
        //                 if(flowerbed[i-1]===0&&flowerbed[i+1]===0){
        //                     flowerbed[i]=1
        //                     count++
        //                 }
        //             }
        //         }
        //     }
        //     return count>=n
        // };
//æ–¹æ³•2:ä¹Ÿæ²¡å¼•å…¥æ–°çš„å˜é‡è¿›è¡Œstoreï¼Œè€Œä¸”ä¸€ä¸ªfor loopä¹ŸåŒ…å«äº†ã€ã€‘ä¸¤è¾¹çš„itemçš„æƒ…å†µ

        //  function canPlaceFlowers(flowerbed, n) {
        //   for (let i = 0; i < flowerbed.length; i++) {
        //     if (flowerbed[i] === 0) {
        //       if (flowerbed[i - 1] !== 1 && flowerbed[i + 1] !== 1) {
        //         n--
        //         flowerbed[i] = 1
        //       }
        //     }
        //   }
        
        //   return n <= 0


        // };
//---------------628. Maximum Product of Three Numbers---------------
//Given an integer array nums, find three numbers whose product is maximum and return the maximum product.
 //è¿™é“é¢˜å°±æ˜¯æ±‚ä¸€ä¸ªarrayä¸­å“ªä¸‰ä¸ªæ•°ç›¸ä¹˜å¾—åˆ°æœ€å¤§å€¼
 //ä¸»è¦æ˜ç¡®ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯å…¨éƒ¨ä¸ºæ­£æ•´æ•°ï¼Œä¸€ç§å°±æ˜¯å­˜åœ¨è´Ÿæ•°çš„æƒ…å†µ
 //æ‰€ä»¥å…ˆå¯¹arrayè¿›è¡Œä»å°åˆ°å¤§çš„æ’åºï¼Œç„¶åå¯¹æœ€å¤§çš„æ­£æ•´æ•°ç›¸ä¹˜ï¼Œç„¶åå†å¯¹å‰ä¸¤ä¸ªè´Ÿæ•°ç›¸ä¹˜ï¼Œå¾—åˆ°çš„æ­£æ•°å’Œæœ€åçš„ä¸€é¡¹æ­£æ•°ç›¸ä¹˜ï¼Œæ¯”è¾ƒä¸¤ä¸ªæ•°çš„å¤§å°ï¼Œå–æœ€å¤§çš„é‚£ä¸ª
// function  maximumProduct (nums) {
//     let leng = nums.length
//     let sorted = nums.sort((a, b) => a - b)
//     pro1 = sorted[leng - 1] * sorted[leng - 2] * sorted[leng - 3]
//     pro2 = sorted[0] * sorted[1] * sorted[leng - 1]
//     return Math.max(pro1, pro2)

//   };

  //---------------643. Maximum Average Subarray I---------------
  //You are given an integer array nums consisting of n elements, and an integer k.
//Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value.
//Any answer with a calculation error less than 10 - 5 will be accepted.
  // Input: nums = [1, 12, -5, -6, 50, 3], k = 4
  // Output: 12.75000
  // Explanation: Maximum average is(12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
  //å…¶å®è¿™ä¸ªé—®é¢˜ç”¨ æ»‘åŠ¨çª—å£ç®—æ³•ã€‚ æ»‘åŠ¨çª—å£åªéœ€è®¡ç®—ç¬¬ä¸€ä¸ªé•¿åº¦ä¸º k çš„å­æ•°ç»„çš„å’Œï¼Œä¹‹åæ¯æ¬¡ç§»åŠ¨çª—å£æ—¶ï¼Œ
  //åªéœ€åœ¨å‰ä¸€ä¸ªçª—å£å’Œçš„åŸºç¡€ä¸ŠåŠ ä¸Šä¸€ä¸ªæ–°å…ƒç´ ï¼Œå‡å»ä¸€ä¸ªæ—§å…ƒç´ ï¼Œä»è€Œå°†å¤æ‚åº¦é™ä½åˆ° O(n)

// function findMaxAverage (nums, k) {
//     let sum = 0
//     for (let i = 0; i < k; i++) {
//       sum += nums[i]
//     }
//     let max = sum
//     for (let j = k; j < nums.length; j++) {
//       sum = sum - nums[j - k] + nums[j]
//       max = Math.max(sum, max)
//     }

//     return max / k
//   };

  //---------------661. Image Smoother---------------
  //An image smoother is a filter of the size 3 x 3 that can be applied to each cell
  // of an image by rounding down the average of the cell and the eight surrounding cells 
  //(i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding 
  //cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).
  //Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.
  //è¿™é“é¢˜å…¶å®å°±æ˜¯è¦ç†è§£å›ºå®šçš„ 3 x 3çš„æ–¹æ ¼ä¸­æ‰€æœ‰å­˜åœ¨çš„itemçš„å¹³å‡å€¼æ”¾å…¥åŸæ¥çš„itemä¸­ï¼Œç»„æˆä¸€ä¸ªæ–°çš„arrayï¼Œ
  //æ‰€ä»¥è§£å†³æ–¹æ³•å°±æ˜¯loopè¿™ä¸ªmatrix arrayï¼Œå¯¹æ¯ä¸ªitemè¿›è¡Œåˆ¤å®šå‘¨è¾¹çš„3 x 3æ–¹æ ¼æ‰€åŒ…å«çš„items
  // function imageSmoother  (img) {
  //   const rows = img.length;       // çŸ©é˜µçš„è¡Œæ•°
  //   const cols = img[0].length;    // çŸ©é˜µçš„åˆ—æ•°

  //   // åˆå§‹åŒ–ç»“æœçŸ©é˜µ Oï¼ˆm*nï¼‰
  //   const res = Array.from({ length: rows }, () => Array(cols).fill(0));

  //   // éå†çŸ©é˜µçš„æ¯ä¸ªå•å…ƒæ ¼
  //   for (let y = 0; y < rows; y++) {
  //     for (let x = 0; x < cols; x++) {
  //       let sum = 0;         // é‚»å±…å€¼çš„å’Œ
  //       let count = 0;       // æœ‰æ•ˆé‚»å±…çš„æ•°é‡

  //       // éå† 3Ã—3 èŒƒå›´
  //       for (let i = -1; i <= 1; i++) {
  //         for (let j = -1; j <= 1; j++) {
  //           const newY = y + i;
  //           const newX = x + j;

  //           // æ£€æŸ¥è¾¹ç•Œæ¡ä»¶
  //           if (newY >= 0 && newY < rows && newX >= 0 && newX < cols) {
  //             sum += img[newY][newX];
  //             count++;
  //           }
  //         }
  //       }

  //       // è®¡ç®—å¹³å‡å€¼å¹¶å‘ä¸‹å–æ•´
  //       res[y][x] = Math.floor(sum / count);
  //     }
  //   }

  //   return res;

  // };
//-------------674. Longest Continuous Increasing Subsequence----------------
  //æ–¹æ³•1
// function findLengthOfLCIS (nums) {
//     let max = 1
//     let count = 1
//     let left = nums[0]
//     for (let i = 1; i < nums.length; i++) {
//       if (nums[i] > left) {
//         count++

//       } else {
//         if (count > max) {
//           max = count
//         }
//         count = 1


//       }
//       left = nums[i]

//     }
//     return Math.max(max, count)

//   };
  //æ–¹æ³•2
  // function findLengthOfLCIS(nums) {
  //     if (nums.length === 0) {
  //         return 0;
  //     }

  //     let res = 1, length = 1;

  //     for (let i = 1; i < nums.length; i++) {
  //         if (nums[i] > nums[i - 1]) {
  //             length++;
  //         } else {
  //             res = Math.max(res, length);
  //             length = 1;
  //         }
  //     }

  //     return Math.max(res, length);
  // }
//--------------------697. Degree of an Array-----------------------
//Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.
//Your task is to find the smallest possible length of a(contiguous) subarray of nums, that has the same degree as nums.
  // Input: nums = [1, 2, 2, 3, 1, 4, 2]
  // Output: 6
  // Explanation: 
  // The degree is 3 because the element 2 is repeated 3 times.
  //   So[2, 2, 3, 1, 4, 2] is the shortest subarray, therefore returning 6.
//è¿™é“é¢˜ä¸»è¦æ˜¯ç»“åˆäº†Map()å’Œè§£æ„èµ‹å€¼è¯­æ³•(destructuring assignment)çš„ç”¨æ³•
//é€šè¿‡åˆ›å»ºä¸€ä¸ªmap,é‡Œé¢åŒ…å«å¾ˆå¤šçš„key-value pairsï¼Œvalue=[count,startIndex,endIndex]
//æœ€åå†æ‰¾åˆ°mapä¸­countæœ€å¤§çš„valueï¼Œå¾—åˆ°æœ€çŸ­çš„subarray
  // function findShortestSubArray(nums) {
  //   let map = new Map()
  //   let freq = 0
  //   let smallest = nums.length

  //   for (let i = 0; i < nums.length; i++) {
  //     let num = nums[i]
  //     if (!map.has(num)) {
  //       map.set(num, [1, i, i])
  //     } else {
  //       let [count, start, _] = map.get(num)
  //       map.set(num, [count + 1, start, i])
  //     }
  //     freq = Math.max(freq, map.get(num)[0])

  //   }
  //   for (let [_, values] of map) {
  //     let [c, s, e] = values
  //     if (c === freq) {
  //       smallest = Math.min(smallest, e - s + 1)

  //     }
  //   }
  //   return smallest

  // };

  //-----------------724. Find Pivot Index----------------------
  //Given an array of integers nums, calculate the pivot index of this array.
//The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.
//If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left.This also applies to the right edge of the array.
//Return the leftmost pivot index.If no such index exists, return -1.
 //å°±æ˜¯æ‰¾åˆ°ä¸€ä¸ªitemï¼Œitemå·¦è¾¹çš„sum å’Œå³è¾¹çš„sum ç›¸ç­‰ï¼Œreturn itemçš„index
  //æ–¹æ³•1:
  // function  pivotIndex(nums) {


  //     for (let i = 0; i < nums.length; i++) {
  //       let left = 0
  //       for (let l = 0; l < i; l++) {
  //         left += nums[l]
  //       }
  //       let right = 0
  //       for (let j = i + 1; j < nums.length; j++) {
  //         right += nums[j]
  //       }
  //       if (left === right) {
  //         return i
  //       }

  //     }
  //     return -1

  //   };
  //   //æ–¹æ³•2 è¿™ç§æ–¹å¼æ›´å¿«
  //   function pivotIndex(nums) {
  //       if (nums.length <= 0) {
  //         return -1;
  //       }

  //       let sum = 0, leftSum = 0;

  //       // è®¡ç®—æ•°ç»„æ€»å’Œ
  //       for (const num of nums) {
  //         sum += num;
  //       }

  //       // éå†æ•°ç»„ï¼Œå¯»æ‰¾æ¢è½´ç´¢å¼•
  //       for (let index = 0; index < nums.length; index++) {
  //         const num = nums[index];
  //         if (leftSum * 2 + num === sum) {
  //           return index; // æ‰¾åˆ°æ¢è½´ç´¢å¼•
  //         }
  //         leftSum += num;
  //       }

  //       return -1; // æœªæ‰¾åˆ°æ¢è½´ç´¢å¼•
  //     }

  //     // ç¤ºä¾‹ç”¨æ³•
  //     console.log(pivotIndex([1, 7, 3, 6, 5, 6])); // è¾“å‡º: 3
  //     console.log(pivotIndex([1, 2, 3]));          // è¾“å‡º: -1
  //     console.log(pivotIndex([2, 1, -1]));         // è¾“å‡º: 0

  //-----------------746. Min Cost Climbing Stairs----------------------
  // You are given an integer array cost where cost[i] is the cost of ith step on a staircase.Once you pay the cost, you can either climb one or two steps.
  // You can either start from the step with index 0, or the step with index 1.
  // Return the minimum cost to reach the top of the floor.
  // Input: cost = [10, 15, 20]
  // Output: 15
  // Explanation: You will start at index 1. - Pay 15 and climb two steps to reach the top.
  // The total cost is 15.
//è¿™é“é¢˜å’Œ70é¢˜å¾ˆåƒ,éƒ½æ˜¯å…³äºçˆ¬æ¥¼çš„é—®é¢˜
// function  minCostClimbingStairs (cost) {
//       cost.push(0)
//       for (let i = cost.length - 3; i >= 0; i--) {
//         cost[i] = Math.min(cost[i] + cost[i + 1], cost[i] + cost[i + 2])
//       }
//       return Math.min(cost[0], cost[1])
//     };
//-------------------------------70. Climbing Stairs-----------------------------
//è§£ç­”è§†é¢‘ï¼šhttps://www.youtube.com/watch?v=Y0lT9Fck7qI 
//You are climbing a staircase.It takes n steps to reach the top.
//Each time you can either climb 1 or 2 steps.In how many distinct ways can you climb to the top ?
//Input: n = 3
//Output: 3
//Explanation: There are three ways to climb to the top.
//1. 1 step + 1 step + 1 step
//2. 1 step + 2 steps
//3. 2 steps + 1 step

// function climbStairs  (n) {
//     let one = 1, two = 1
//     for (let i = 0; i < n - 1; i++) {
//       let temp = one
//       one = one + two
//       two = temp
//     }
//     return one
//   };
//-----------------------766. Toeplitz Matrix-----------------
//Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.
//A matrix is Toeplitz if every diagonal from top - left to bottom - right has the same elements
//ç»™å‡ºä¸€ä¸ªçŸ©é˜µï¼Œè¦æ±‚åˆ¤æ–­çŸ©é˜µæ‰€æœ‰å¯¹è§’æ–œçº¿ä¸Šçš„æ•°å­—æ˜¯å¦éƒ½æ˜¯ä¸€ä¸ªæ•°å­—ã€‚
 </script>

</body>

</html>