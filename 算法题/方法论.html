<!DOCTYPE html>
<html lang="en">

<head>
    <title>Web App</title>
    <style>





    </style>
</head>

<body>


    <script>
    // 一：双指针法（Two Pointers Technique）是一种常用的算法技巧，通常用于解决数组或链表相关的问题。
    //它的核心思想是使用两个指针（或索引）在数据结构中同时移动，从而高效地解决问题。以下是双指针法的常见应用场景和适用条件：
    //（1）有序数组或链表中的搜索问题
      //问题特点：数据已经排序，需要找到满足特定条件的两个元素。
      //示例：在有序数组中查找两个数，使它们的和等于目标值。
           //在链表中找到中间节点或倒数第 k 个节点。
        //    输入：nums = [2, 7, 11, 15], target = 9
        //    输出：[2, 7]
        //    function twoSum(nums, target) {
        //         let left = 0;
        //         let right = nums.length - 1;
        //         while (left < right) {
        //             const sum = nums[left] + nums[right];
        //             if (sum === target) {
        //                 return [nums[left], nums[right]];
        //             } else if (sum < target) {
        //                 left++;
        //             } else {
        //                 right--;
        //             }
        //         }
        //         return [];
        //     }

    //（2）翻转或反转问题
      // 问题特点：需要翻转或反转数组、字符串或链表。
      // 示例：翻转数组或字符串；反转链表。
        // 输入：nums = [1, 2, 3, 4, 5]
        // 输出：[5, 4, 3, 2, 1]
        // function reverseArray(nums) {
        //         let left = 0;
        //         let right = nums.length - 1;
        //         while (left < right) {
        //             [nums[left], nums[right]] = [nums[right], nums[left]];
        //             left++;
        //             right--;
        //         }
        //         return nums;
        //     }
    // （3）滑动窗口问题（相似题型 643--Maximum Average Subarray I）
      //问题特点：需要在数组或字符串中找到满足条件的子数组或子字符串。
      //示例：找到和大于等于目标值的最短子数组；找到不包含重复字符的最长子字符串。
    //   输入：nums = [2, 3, 1, 2, 4, 3], target = 7
    //   输出：2（子数组[4, 3] 的和为 7）
    //   function minSubArrayLen(nums, target) {
    //         let left = 0;
    //         let sum = 0;
    //         let minLen = Infinity;
    //         for (let right = 0; right < nums.length; right++) {
    //             sum += nums[right];
    //             while (sum >= target) {
    //                 minLen = Math.min(minLen, right - left + 1);
    //                 sum -= nums[left];
    //                 left++;
    //             }
    //         }
    //         return minLen === Infinity ? 0 : minLen;
    //     }

    //（4）快慢指针问题
      //问题特点：需要检测链表中的环或找到链表的特定节点。
      //示例：检测链表是否有环；找到链表的中间节点。
    //   输入：链表 1 -> 2 -> 3 -> 4 -> 2（形成环）
    //   输出：true
    //   function hasCycle(head) {
    //         let slow = head;
    //         let fast = head;
    //         while (fast && fast.next) {
    //             slow = slow.next;
    //             fast = fast.next.next;
    //             if (slow === fast) {
    //                 return true;
    //             }
    //         }
    //         return false;
    //     }

    //（5）移除有序数组中的重复项--问题描述：移除有序数组中的重复项，并返回新数组的长度。
      // 输入：nums = [1, 1, 2, 2, 3]
      // 输出：3（新数组为[1, 2, 3]）
      // function removeDuplicates(nums) {
      //     if (nums.length === 0) return 0;

      //     let slow = 0; // 慢指针
      //     for (let fast = 1; fast < nums.length; fast++) { // 快指针
      //       if (nums[fast] !== nums[slow]) {
      //         slow++;
      //         nums[slow] = nums[fast]; // 将不重复的元素移到前面
      //       }
      //     }

      //     return slow + 1; // 返回新数组的长度
      //   }

      //（6）830. Positions of Large Groups，也是重复项目的处理问题
      // Input: s = "abbxxxxzzy"
        // Output: [[3, 6]]
      //返回连续重复超过3个点子集

      //（7）移除元素 时间O(n)  空间O(1)
      //给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
      //不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
      //元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
      //示例 2: 给定 nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
      //  let removeElement=(nums,val)=>{
      //   let k=0
      //   for(let i=0;i<nums.length;i++){
      //     if(nums[i]!==val){
      //       nums[k]=nums[i]
      //       k++
      //     }
      //   }
      //   return k

      //  }



//2.二分搜索（Binary Search）：数据必须有序，通常用于在有序数组中查找目标值或者其位置，没有重复的item

//核心思想：（1）初始化两个指针：left 和 right，分别指向数组的起始和末尾。
//        （2）计算中间位置 mid = (left + right) / 2。 也可以  mid=(left+(right-left)/2)
//        （3）比较 mid 处的值与目标值：
                        //如果相等，返回结果。
                        //如果目标值小于 mid 处的值，将 right 移动到 mid - 1。
                        //如果目标值大于 mid 处的值，将 left 移动到 mid + 1。
                        //重复上述步骤，直到 left > right。

//O(log n)：每次将搜索范围缩小一半。

 // 1. while (left <= right)
//  适用场景：寻找确切值或确定元素是否存在
//   搜索区间：[left, right]（闭区间）
//   循环结束时：left > right
//   每个元素都会被检查
//   例子：在有序数组中查找目标值

//2. while (left < right)
//适用场景：寻找边界或第一个 / 最后一个满足条件的元素
//搜索区间：[left, right)（左闭右开）
//循环结束时：left == right
//不会检查所有元素，更高效
//例子：寻找第一个错误版本


//经典结构：
    // function binarySearch(nums, target) {
    //     let left = 0;
    //     let right = nums.length - 1;

    //     while (left <= right) {
    //         const mid = Math.floor((left + right) / 2);
    //         if (nums[mid] === target) {
    //             return mid; // 找到目标值，返回索引
    //         } else if (nums[mid] < target) {
    //             left = mid + 1;
    //         } else {
    //             right = mid - 1;
    //         }
    //     }

    //     return -1; // 未找到目标值，若是要插入则  return left;
    // }


//3. 最大子数组和问题（Maximum Subarray Problem），通常使用 Kadane's Algorithm 来解决。
//它的核心思想是通过动态规划的思想，在遍历数组时不断更新当前子数组的最大和，并记录全局的最大和。

//例如：00053:Maximum Subarray
//Given an integer array nums, find the subarray with the largest sum, and return its sum.
// A subarray is a contiguous part of an array
//分析：因为最后需要return的是maximum sum，所以不用管是那几个连续的数字，只需要用一个
// max 变量进行比较记录.逻辑思维：比较自身和自身与前面的数字相加进行比大小，大于maxSum就update sum最大值，
  // Input: nums = [-2 ,1, -3, 4, -1, 2, 1, -5, 4]
  // Output: 6
  // Explanation: The subarray[4, -1, 2, 1] has the largest sum 6.

  //nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  //currnetSum: -2  1  -2       4   3       5   6   1        5
  // maxSum:    -2  1   1(不变)  4   4（不变）5   6   6（不变） 6（不变）
  
  // function maxSubArray(nums) {
  //   if (nums.length === 0) {
  //     return 0
  //   }
  //   if (nums.length === 1) {
  //     return nums[0]
  //   }
  //   let currentSum = nums[0]
  //   let maxSum = nums[0]
  //   for (let i = 1; i < nums.length; i++) {
  //     currentSum = Math.max(nums[i], nums[i] + currentSum)//如果 currentSum + nums[i] 比 nums[i] 本身大，说明当前子数组可以继续扩展。否则，从 nums[i] 开始一个新的子数组。
  //     maxSum = Math.max(maxSum, currentSum)
  //   }
  //   return maxSum

  // }

  //改进：如果想知道最大的subarray的具体数字，我们需要额外记录子数组的起始和结束位置，以便最终提取出对应的子数组：
//   function maxSubArray(nums) {
//         if (nums.length === 0) return { maxSum: 0, subarray: [] }; // 空数组返回0和空子数组

//         let maxSum = nums[0]; // 全局最大子数组和
//         let curSum = nums[0]; // 当前子数组和
//         let start = 0; // 最大子数组的起始位置
//         let end = 0;   // 最大子数组的结束位置
//         let tempStart = 0; // 临时起始位置，用于更新起始位置

//         for (let i = 1; i < nums.length; i++) {
//             // 如果当前元素比 curSum + nums[i] 更大，则从当前元素开始新的子数组
//             if (nums[i] > curSum + nums[i]) {
//                 curSum = nums[i]; // 从当前元素开始新的子数组
//                 tempStart = i;   // 更新临时起始位置
//             } else {
//                 curSum += nums[i]; // 继续扩展当前子数组
//             }

//             // 更新全局最大子数组和及其位置
//             if (curSum > maxSum) {
//                 maxSum = curSum;
//                 start = tempStart; // 更新起始位置
//                 end = i;           // 更新结束位置
//             }
//         }

//         // 返回最大子数组和以及对应的子数组
//         return {
//             maxSum: maxSum,
//             subarray: nums.slice(start, end + 1), // 提取子数组
//         };
//     }

//     // 示例用法：
//     const nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
//     const result = maxSubArray(nums);
//     console.log("最大子数组和:", result.maxSum); // 输出: 6
//     console.log("对应的子数组:", result.subarray); // 输出: [4, -1, 2, 1]


//4.Pascals Triangle---leetcode 118,119
//In Pascal's triangle, each number is the sum of the two numbers directly above it
//Input: numRows = 5
//Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
// function generate(numRows){
//     if(numbRow===0) return []
//     if (numbRow === 1) return [[1]]
//     //[[1],[1]]
//     let triangle=[[1]]
//     for(let i=1;i<numRows;i++){
//         let preRow=triangle[i-1]
//         let curRow=[]
//         curRow.push(1)
//         for(let j=1;j<preRow.length;j++){
//             curRow[j]=preRow[j]+preRow[j-1]

//         }
//         curRow.push(1)
//         triangle.push(curRow)

//     }
//     return triangle


// }

//5.Map的储存和应用 
//let map=new Map()
//functions: map.set(key,values)  
//           map.has(key)---true/false
//           map.get(key)---values([a,b,c])
//           map.delete(key)
//--------------------697. Degree of an Array-----------------------
    //Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.
    //Your task is to find the smallest possible length of a(contiguous) subarray of nums, that has the same degree as nums.
    //先找出最频繁出现的number，然后找出最短的含有这个重复number的subarray
    // Input: nums = [1, 2, 2, 3, 1, 4, 2]
    // Output: 6
    // Explanation:
    // The degree is 3 because the element 2 is repeated 3 times.
    //   So[2, 2, 3, 1, 4, 2] is the shortest subarray, therefore returning 6.
    //这道题主要是结合了Map()和解构赋值语法(destructuring assignment)的用法
    //通过创建一个map,里面包含很多的key-value pairs，value=[count,startIndex,endIndex]
    //最后再找到map中count最大的value，得到最短的subarray
    // function findShortestSubArray(nums) {
    //   let map = new Map()
    //   let freq = 0
    //   let smallest = nums.length

    //   for (let i = 0; i < nums.length; i++) {
    //     let num = nums[i]
    //     if (!map.has(num)) {
    //       map.set(num, [1, i, i])
    //     } else {
    //       let [count, start, _] = map.get(num)
    //       map.set(num, [count + 1, start, i])
    //     }
    //     freq = Math.max(freq, map.get(num)[0])

    //   }
    //   for (let [_, values] of map) {
    //     let [c, s, e] = values
    //     if (c === freq) {
    //       smallest = Math.min(smallest, e - s + 1)

    //     }
    //   }
    //   return smallest

    // };


//6 .Matrix的复杂问题

  //-----------------------766. Toeplitz Matrix-----------------
  //Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.
  //A matrix is Toeplitz if every diagonal from top - left to bottom - right has the same elements
  //给出一个矩阵，要求判断矩阵所有对角斜线上的数字是否都是一个数字。
  //需要注意的是，会在长度的前一个结束loop，matrix[i + 1][j + 1])必须存在
  // function isToeplitzMatrix  (matrix) {
  // for (let i = 0; i < matrix.length - 1; i++) {
  //     for (let j = 0; j < matrix[0].length - 1; j++) {
  //       if (matrix[i][j] !== matrix[i + 1][j + 1]) {
  //         return false
  //       }
  //     }
  //   }
  //   return true

  // };

  //-------------------- 867. Transpose Matrix----------------------------
      // Given a 2D integer array matrix, return the transpose of matrix.
      //   Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
      // Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
      //思路就是建造一个新的array，然后再将以前的matrix中的数字放进去
      // var transpose = function (matrix) {
      //   let row = matrix.length//2
      //   let col = matrix[0].length//3
      //   let arr = new Array(col)//[,,]
      //   for (let i = 0; i < col; i++) {
      //     arr[i] = new Array(row)
      //   }
      //   for (let i = 0; i < row; i++) {
      //     for (let j = 0; j < col; j++) {
      //       arr[j][i] = matrix[i][j]
      //     }
      //   }
      //   return arr

      // };


  //---------------661. Image Smoother---------------
    //An image smoother is a filter of the size 3 x 3 that can be applied to each cell
    // of an image by rounding down the average of the cell and the eight surrounding cells
    //(i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding
    //cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).
    //Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.
    //这道题其实就是要理解固定的 3 x 3的方格中所有存在的item的平均值放入原来的item中，组成一个新的array，
    //所以解决方法就是loop这个matrix array，对每个item进行判定周边的3 x 3方格所包含的items
    // function imageSmoother  (img) {
    //   const rows = img.length;       // 矩阵的行数
    //   const cols = img[0].length;    // 矩阵的列数

    //   // 初始化结果矩阵 O（m*n）
    //   const res = Array.from({ length: rows }, () => Array(cols).fill(0));

    //   // 遍历矩阵的每个单元格
    //   for (let y = 0; y < rows; y++) {
    //     for (let x = 0; x < cols; x++) {
    //       let sum = 0;         // 邻居值的和
    //       let count = 0;       // 有效邻居的数量

    //       // 遍历 3×3 范围
    //       for (let i = -1; i <= 1; i++) {
    //         for (let j = -1; j <= 1; j++) {
    //           const newY = y + i;
    //           const newX = x + j;

    //           // 检查边界条件
    //           if (newY >= 0 && newY < rows && newX >= 0 && newX < cols) {
    //             sum += img[newY][newX];
    //             count++;
    //           }
    //         }
    //       }

    //       // 计算平均值并向下取整
    //       res[y][x] = Math.floor(sum / count);
    //     }
    //   }

    //   return res;

    // };

    </script>

</body>

</html>