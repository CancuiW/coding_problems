<!DOCTYPE html>
<html lang="en">

<head>
    <title>Web App</title>
    <style>





    </style>
</head>

<body>


    <script>
    // 一：双指针法（Two Pointers Technique）是一种常用的算法技巧，通常用于解决数组或链表相关的问题。
    //它的核心思想是使用两个指针（或索引）在数据结构中同时移动，从而高效地解决问题。以下是双指针法的常见应用场景和适用条件：
    //（1）有序数组或链表中的搜索问题
      //问题特点：数据已经排序，需要找到满足特定条件的两个元素。
      //示例：在有序数组中查找两个数，使它们的和等于目标值。
           //在链表中找到中间节点或倒数第 k 个节点。
        //    输入：nums = [2, 7, 11, 15], target = 9
        //    输出：[2, 7]
        //    function twoSum(nums, target) {
        //         let left = 0;
        //         let right = nums.length - 1;
        //         while (left < right) {
        //             const sum = nums[left] + nums[right];
        //             if (sum === target) {
        //                 return [nums[left], nums[right]];
        //             } else if (sum < target) {
        //                 left++;
        //             } else {
        //                 right--;
        //             }
        //         }
        //         return [];
        //     }

    //（2）翻转或反转问题
      // 问题特点：需要翻转或反转数组、字符串或链表。
      // 示例：翻转数组或字符串；反转链表。
        // 输入：nums = [1, 2, 3, 4, 5]
        // 输出：[5, 4, 3, 2, 1]
        // function reverseArray(nums) {
        //         let left = 0;
        //         let right = nums.length - 1;
        //         while (left < right) {
        //             [nums[left], nums[right]] = [nums[right], nums[left]];
        //             left++;
        //             right--;
        //         }
        //         return nums;
        //     }
    // （3）滑动窗口问题（相似题型 643--Maximum Average Subarray I）
      //问题特点：需要在数组或字符串中找到满足条件的子数组或子字符串。
      //示例：找到和大于等于目标值的最短子数组；找到不包含重复字符的最长子字符串。
    //   输入：nums = [2, 3, 1, 2, 4, 3], target = 7
    //   输出：2（子数组[4, 3] 的和为 7）
    //   function minSubArrayLen(nums, target) {
    //         let left = 0;
    //         let sum = 0;
    //         let minLen = Infinity;
    //         for (let right = 0; right < nums.length; right++) {
    //             sum += nums[right];
    //             while (sum >= target) {
    //                 minLen = Math.min(minLen, right - left + 1);
    //                 sum -= nums[left];
    //                 left++;
    //             }
    //         }
    //         return minLen === Infinity ? 0 : minLen;
    //     }

    //（4）快慢指针问题
      //问题特点：需要检测链表中的环或找到链表的特定节点。
      //示例：检测链表是否有环；找到链表的中间节点。
    //   输入：链表 1 -> 2 -> 3 -> 4 -> 2（形成环）
    //   输出：true
    //   function hasCycle(head) {
    //         let slow = head;
    //         let fast = head;
    //         while (fast && fast.next) {
    //             slow = slow.next;
    //             fast = fast.next.next;
    //             if (slow === fast) {
    //                 return true;
    //             }
    //         }
    //         return false;
    //     }

//2.二分搜索（Binary Search）：数据必须有序，通常用于在有序数组中查找目标值或者其位置

//核心思想：（1）初始化两个指针：left 和 right，分别指向数组的起始和末尾。
//        （2）计算中间位置 mid = (left + right) / 2。
//        （3）比较 mid 处的值与目标值：
                        //如果相等，返回结果。
                        //如果目标值小于 mid 处的值，将 right 移动到 mid - 1。
                        //如果目标值大于 mid 处的值，将 left 移动到 mid + 1。
                        //重复上述步骤，直到 left > right。
//O(log n)：每次将搜索范围缩小一半。
    // function binarySearch(nums, target) {
    //     let left = 0;
    //     let right = nums.length - 1;

    //     while (left <= right) {
    //         const mid = Math.floor((left + right) / 2);
    //         if (nums[mid] === target) {
    //             return mid; // 找到目标值，返回索引
    //         } else if (nums[mid] < target) {
    //             left = mid + 1;
    //         } else {
    //             right = mid - 1;
    //         }
    //     }

    //     return -1; // 未找到目标值
    // }


//3. 最大子数组和问题（Maximum Subarray Problem），通常使用 Kadane's Algorithm 来解决。
//它的核心思想是通过动态规划的思想，在遍历数组时不断更新当前子数组的最大和，并记录全局的最大和。

//例如：00053:Maximum Subarray
//Given an integer array nums, find the subarray with the largest sum, and return its sum.
// A subarray is a contiguous part of an array
//分析：因为最后需要return的是maximum sum，所以不用管是那几个连续的数字，只需要用一个
// max 变量进行比较记录.逻辑思维：比较自身和自身与前面的数字相加进行比大小，大于maxSum就update sum最大值，
  // Input: nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  // Output: 6
  // Explanation: The subarray[4, -1, 2, 1] has the largest sum 6.

  //nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
  //currnetSum: -2  1  -2       4   3       5   6   1        5
  // maxSum:    -2  1   1(不变)  4   4（不变）5   6   6（不变） 6（不变）
  
  // function maxSubArray(nums) {
  //   if (nums.length === 0) {
  //     return 0
  //   }
  //   if (nums.length === 1) {
  //     return nums[0]
  //   }
  //   let currentSum = nums[0]
  //   let maxSum = nums[0]
  //   for (let i = 1; i < nums.length; i++) {
  //     currentSum = Math.max(nums[i], nums[i] + currentSum)//如果 currentSum + nums[i] 比 nums[i] 本身大，说明当前子数组可以继续扩展。否则，从 nums[i] 开始一个新的子数组。
  //     maxSum = Math.max(maxSum, currentSum)
  //   }
  //   return maxSum

  // }

  //改进：如果想知道最大的subarray的具体数字，我们需要额外记录子数组的起始和结束位置，以便最终提取出对应的子数组：
//   function maxSubArray(nums) {
//         if (nums.length === 0) return { maxSum: 0, subarray: [] }; // 空数组返回0和空子数组

//         let maxSum = nums[0]; // 全局最大子数组和
//         let curSum = nums[0]; // 当前子数组和
//         let start = 0; // 最大子数组的起始位置
//         let end = 0;   // 最大子数组的结束位置
//         let tempStart = 0; // 临时起始位置，用于更新起始位置

//         for (let i = 1; i < nums.length; i++) {
//             // 如果当前元素比 curSum + nums[i] 更大，则从当前元素开始新的子数组
//             if (nums[i] > curSum + nums[i]) {
//                 curSum = nums[i]; // 从当前元素开始新的子数组
//                 tempStart = i;   // 更新临时起始位置
//             } else {
//                 curSum += nums[i]; // 继续扩展当前子数组
//             }

//             // 更新全局最大子数组和及其位置
//             if (curSum > maxSum) {
//                 maxSum = curSum;
//                 start = tempStart; // 更新起始位置
//                 end = i;           // 更新结束位置
//             }
//         }

//         // 返回最大子数组和以及对应的子数组
//         return {
//             maxSum: maxSum,
//             subarray: nums.slice(start, end + 1), // 提取子数组
//         };
//     }

//     // 示例用法：
//     const nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
//     const result = maxSubArray(nums);
//     console.log("最大子数组和:", result.maxSum); // 输出: 6
//     console.log("对应的子数组:", result.subarray); // 输出: [4, -1, 2, 1]


//4.Pascals Triangle---leetcode 118,119
//In Pascal's triangle, each number is the sum of the two numbers directly above it
//Input: numRows = 5
//Output: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
// function generate(numRows){
//     if(numbRow===0) return []
//     if (numbRow === 1) return [[1]]
//     //[[1],[1]]
//     let triangle=[[1]]
//     for(let i=1;i<numRows;i++){
//         let preRow=triangle[i-1]
//         let curRow=[]
//         curRow.push(1)
//         for(let j=1;j<preRow.length;j++){
//             curRow[j]=preRow[j]+preRow[j-1]

//         }
//         curRow.push(1)
//         triangle.push(curRow)

//     }
//     return triangle


// }

//5.Map的储存和应用 
//let map=new Map()
//functions: map.set(key,values)  
//           map.has(key)---true/false
//           map.get(key)---values([a,b,c])
//           map.delete(key)
//--------------------697. Degree of an Array-----------------------
    //Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.
    //Your task is to find the smallest possible length of a(contiguous) subarray of nums, that has the same degree as nums.
    //先找出最频繁出现的number，然后找出最短的含有这个重复number的subarray
    // Input: nums = [1, 2, 2, 3, 1, 4, 2]
    // Output: 6
    // Explanation:
    // The degree is 3 because the element 2 is repeated 3 times.
    //   So[2, 2, 3, 1, 4, 2] is the shortest subarray, therefore returning 6.
    //这道题主要是结合了Map()和解构赋值语法(destructuring assignment)的用法
    //通过创建一个map,里面包含很多的key-value pairs，value=[count,startIndex,endIndex]
    //最后再找到map中count最大的value，得到最短的subarray
    // function findShortestSubArray(nums) {
    //   let map = new Map()
    //   let freq = 0
    //   let smallest = nums.length

    //   for (let i = 0; i < nums.length; i++) {
    //     let num = nums[i]
    //     if (!map.has(num)) {
    //       map.set(num, [1, i, i])
    //     } else {
    //       let [count, start, _] = map.get(num)
    //       map.set(num, [count + 1, start, i])
    //     }
    //     freq = Math.max(freq, map.get(num)[0])

    //   }
    //   for (let [_, values] of map) {
    //     let [c, s, e] = values
    //     if (c === freq) {
    //       smallest = Math.min(smallest, e - s + 1)

    //     }
    //   }
    //   return smallest

    // };

    </script>

</body>

</html>